---
output: 
  html_document:
    code_folding: hide
params:
  ecosites_of_interest: 'placeholder'
  mapunit_boundaries: 'placeholder'
  ecoregion_boundaries: 'placeholder'
  mlra_boundary: 'placeholder'
---
Author: Nathan Roe

Contact: nateroe@gmail.com

Date report was produced: `r format(Sys.time(), '%d %B, %Y')`

Visit the [GitHub repository](https://github.com/natearoe/EDIT_ecosite_data) for version control information and instructions for producing these reports yourself. 

<!-- This is the final step in the 'EDIT ecosite data' workflow. It will produce reports for all the ecosites that you provide -->
<!-- to the corresponding for_loop_file.R.  -->

<!-- Note: You will need to change the file path on line 28. The easiest way to do that is to find the file that you created in -->
<!-- Step 2, your NASIS ecosite report. It should be in the folder with all your other 'EDIT ecosite data' files. Shift + right click > copy as path. Then paste the path in, replacing the existing one. That path will have backslashes \ these all need to be changed to forwardslashes /.  -->

<!-- If you want this file to produce maps of ecosites, you will need to remove the "#" before each line in the last two code blocks and follow the   -->

<!-- #### Packages -->
```{r class.source = "fold-show", message=FALSE, warning=FALSE, echo=FALSE }

```

```{r include = FALSE, echo=FALSE}
knitr::opts_chunk$set(fig.height = 7, fig.width = 9)
```

<!-- **Read in NASIS report** -->
```{r class.source = "fold-show", echo=FALSE}
EDIT_updates <- read.csv("./ecosite_report.csv")
```

<!-- **Remove miscellaneous areas** -->
```{r  class.source = "fold-show", echo=FALSE}
EDIT_updates <- EDIT_updates |>  dplyr::filter(compkind != "miscellaneous area")
```

<!-- **Define ecosite of interest** -->
```{r  class.source = "fold-show", echo=FALSE}
EDIT_updates_filtered <- EDIT_updates |>  dplyr::filter(ecosite_id == 'F022AD102CA')
```

<!-- **Determine component acreage unit** -->
```{r  class.source = "fold-show", echo=FALSE}

comp_acreage_unit <- ifelse(min(EDIT_updates_filtered$comp_acres[EDIT_updates_filtered$comp_acres != 0], na.rm = TRUE) < 100, 1, 
               ifelse(min(EDIT_updates_filtered$comp_acres[EDIT_updates_filtered$comp_acres != 0], na.rm = TRUE) < 1000, 10, 
                      ifelse(min(EDIT_updates_filtered$comp_acres[EDIT_updates_filtered$comp_acres != 0], na.rm = TRUE) < 10000, 100, 
                             ifelse(min(EDIT_updates_filtered$comp_acres[EDIT_updates_filtered$comp_acres != 0], na.rm = TRUE) < 
                                      100000, 1000, 10000))))

```

---
title: <center> `r EDIT_updates_filtered$ecosite_id[1]` ecosite report </center>
---


#### **Important Discussion:**

**Purpose of this report:**

This report summarizes data from components correlated to an ecosite. It could be used to populate EDIT, to QC component-ecosite correlations, or as documentation of ecosite properties. Of particular importance to QC, this document allows you to hover your cursor over graphs to see what coiids are being represented. This allows you to hover over values that look like outliers and identify which coiid(s) might be improperly correlated.

**# of components vs. component acreage:**

The following analysis provides two ways of looking at data - (1) by component and (2) by component acreage. Looking at components (1) means that we treat all components equally, regardless of whether one component has a total acreage of 5 acres and another component has a total acreage of 50,000 acres. Looking at data by component acreage (2) acknowledges that components may differ in their importance based on their acreage. Therefore, you will see figures below that summarize data both by component (1) and by component acreage (2). 

I would suggest that looking at components (1) is the best way to QC your data. The correlation of components to ecosites should be assessed based on the *similarity of properties* between the ecosite and component. A bad component-ecosite correlation can just as easily happen for a component with low acreage as it can for a component with high acreage. For the QC process, you should think of component acreage as a metric of how important it is to have a good component-ecosite correlation. A bad component-ecosite correlation for a high acreage component will be more disruptive to the ecosite concept than a bad component-ecosite correlation for a low acreage component. Why? Continue reading...

**Standardized calculations:**

This report provides a standardized way of populating the range of properties for an ecosite. This is accomplished by weighting components by their acreage, hence why good correlations for high acreage components is important. Component properties are replicated by their associated acres. After replication, the following calculations are used:

Low (actual) - 5th percentile of the component low values
High (actual) - 95th percentile of the component high values
Low (representative) - 20th percentile of the combined component high and component low values
High (representative) - 80th percentile of the combined component high and component low values

As an example of the replication process, let's say we have two components - Component A and Component B. Component A has an acreage of 1. Component B has an acreage of 5. The elevation of Component A is 100 ft. The elevation of Component B is 500 ft. The resulting data set would be: 100, 500, 500, 500, 500, 500. Those values would be used to calculate percentiles. 

NA values mean that there are missing values. Figures do not show NA values but summary statistics do, so be sure to observe the summary statistics below figures to understand how many missing values there are. For water table and restriction depth, NAs can be interpreted as an ordinal value that, for most purposes, are greater than quantitative values. NAs for ponding depth can be interpretted as an ordinal value that, for most purposes, are less than quantitative values. Therefore, NAs are included in statistical summaries for these variables, including calculations of percentiles. 

Values should be rounded appropriate to the data before being entered into EDIT for all numeric fields except pH. 

**EDIT does not accept non-numerics:** 

EDIT does not accept non-numeric values being entered in numeric fields. If you enter non-numeric values, they will be changed to zeros after you save and re-open the site. If a field is not-applicable you should uncheck the box rather than entering NAs. For example, if there is no observed restriction, you should uncheck the depth to restriction box. If you enter NAs those values will be converted to zeros, suggesting that there is a restriction at the soil surface. 

<center><h3> **Physiographic features tab:** </h3></center>

#### **Landform** 

Several properties in EDIT have the option to include multiple values, including landform. Other properties that allow for multiple values to be populated include parent material and surface texture. If there are multiple distinctly different properties that are associated with considerable acreage, than list them. For most situations, one to two values is ideal. More than three values is most likely excessive. 

**Full landform string table by acreage and number of components**
```{r}
if (all(is.na(EDIT_updates_filtered$landform)) | 
    all(EDIT_updates_filtered$landform == "")) {print("No data populated in NASIS for this field.")
  
} else{
  
  landform_df <- EDIT_updates_filtered |>  dplyr::select(coiid, landform, comp_acres) |>  dplyr::group_by(landform) |>  
    dplyr::summarise(acres = sum(comp_acres),  '# components' = dplyr::n()) |>  dplyr::arrange(desc(acres)) |>  as.data.frame()
  
  landform_df

}
```

Wordcloud of acreage weighted landform descriptions. The wordcloud should give an overview of the words used to describe the landform, please view the full landform strings above for explicit details. 
```{r, message=FALSE, warning=FALSE}
if (all(is.na(EDIT_updates_filtered$landform))) {print("No data populated in NASIS for this field.")
  
} else{
  
  acreage_unit <- ifelse(min(landform_df$acres[landform_df$acres != 0], na.rm = TRUE) < 100, 1, 
               ifelse(min(landform_df$acres[landform_df$acres != 0], na.rm = TRUE) < 1000, 10, 
                      ifelse(min(landform_df$acres[landform_df$acres != 0], na.rm = TRUE) < 10000, 100, 
                             ifelse(min(landform_df$acres[landform_df$acres != 0], na.rm = TRUE) < 
                                      100000, 1000, 10000))))
  
  
 landform_words <-  rep(landform_df$landform, plyr::round_any(landform_df$acres/acreage_unit, accuracy = 1, f = round)) |> strsplit(" ") |> unlist() |>   
              stringr::str_replace(",", "")
 
 wordcloud::wordcloud(landform_words)

}
```

**Landform wordcloud table**
```{r, message=FALSE, warning=FALSE}
if (all(is.na(EDIT_updates_filtered$landform))) {print("No data populated in NASIS for this field.")
  
} else{
  
  table(landform_words) |>  as.data.frame() |>  dplyr::arrange(desc(Freq)) |>  dplyr::rename(`Landform words` =
                                                                    landform_words) |> dplyr::top_n(15)
  
}

```

#### **Runoff class**

This field is obsolete and will be removed from EDIT. Enter medium for all values.


#### **Flooding freq.**

```{r}
EDIT_updates_filtered$flood_freq <- ifelse(EDIT_updates_filtered$flood_freq == "", "none", EDIT_updates_filtered$flood_freq)

if (all(is.na(EDIT_updates_filtered$flood_freq))) {print("No data populated in NASIS for this field.")
  
} else{
  
  my_levels <- c(
    "none",
    "very rare",
    "rare",
    "occasional",
    "frequent",
    "very frequent"
  )
  
Flood.freq.df <- EDIT_updates_filtered |>  dplyr::select(coiid, flood_freq, comp_acres)  |>  dplyr::group_by(flood_freq) |>  dplyr::summarise(count = dplyr::n(), acres = sum(comp_acres), coiids = toString(coiid)) |>  dplyr::ungroup() 

Flood.freq.df$flood_freq <- factor(Flood.freq.df$flood_freq, levels = my_levels)

  
ff1 <-
  plotly::plot_ly(
    x = Flood.freq.df$flood_freq,
    y = Flood.freq.df$count,
    type = "bar",
    hoverinfo = "text",
    hovertext = paste("coiids: ", stringr::str_wrap(Flood.freq.df$coiids, 40))
  ) |>  plotly::layout(
    title = "Flood freq. (# components)",
    xaxis = list(title = "Flooding frequency"),
    yaxis = list(title = "# of components"),
    margin = list(t = 100)
  )


ff2 <-
  plotly::plot_ly(
    x = Flood.freq.df$flood_freq,
    y = Flood.freq.df$acres,
    name = "Flood freq. (acres)",
    type = "bar",
    hoverinfo = "text",
    hovertext = paste("coiids: ", stringr::str_wrap(Flood.freq.df$coiids, 40))
  ) |>  plotly::layout(
    title = "Flood freq. (# of acres)",
    xaxis = list(title = "Flooding frequency"),
    yaxis = list(title = "acres"),
    margin = list(t = 100)
  )

manipulateWidget::combineWidgets(ff1,
                                 ff2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))


}
```

**Flooding frequency acreage weighted summary statistics**
```{r}
if (all(is.na(EDIT_updates_filtered$flood_freq))) {print("No data populated in NASIS for this field.")
  
} else{
  
  EDIT_updates_filtered |>  dplyr::select(coiid, flood_freq, comp_acres) |>  dplyr::group_by(flood_freq) |>  
    dplyr::summarise(acres = sum(comp_acres),  '# components' = dplyr::n()) |>  dplyr::arrange(desc(acres)) |>  as.data.frame()

}
```

**Flooding frequency acreage weighted percentiles.**

Actual low (5%) and actual high (95%). Representative low (20%) and representative high (80%).
```{r}
if (all(is.na(EDIT_updates_filtered$flood_freq))) {print("No data populated in NASIS for this field.")
  
} else{
  
      expanded_flood_freq <- rep(EDIT_updates_filtered$flood_freq, 
                               plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit,
                                               accuracy = 1, f = round))
    
    expanded_flood_freq <- expanded_flood_freq[order(match(expanded_flood_freq, my_levels))]
  
    data.frame("5%" = expanded_flood_freq[ceiling(0.05 * length(expanded_flood_freq))],
               "20%" = expanded_flood_freq[ceiling(0.20 * length(expanded_flood_freq))],
               "80%" = expanded_flood_freq[ceiling(0.80 * length(expanded_flood_freq))],
             "95%" = expanded_flood_freq[ceiling(0.95 * length(expanded_flood_freq))],
             check.names = FALSE)

}

```

#### **Flooding duration**

Put "--" for duration if frequency is "none"

```{r, results='asis'}
EDIT_updates_filtered$flood_dur <- ifelse(EDIT_updates_filtered$flood_dur == "", "none", EDIT_updates_filtered$flood_dur)

if (all(is.na(EDIT_updates_filtered$flood_dur))) {print("No data populated in NASIS for this field.")
  
} else{
  
    my_levels <- c(
    "none",
    "extremely brief",
    "very brief",
    "brief",
    "long",
    "very long"
  )
  
  Flood.duration.df <- EDIT_updates_filtered |>  dplyr::select(coiid, flood_dur, comp_acres)  |>  
    dplyr::group_by(flood_dur) |>  dplyr::summarise(count = dplyr::n(), acres = sum(comp_acres),
                coiids = toString(coiid)) |>  dplyr::ungroup() 
  
  Flood.duration.df$flood_dur <- factor(Flood.duration.df$flood_dur, levels = my_levels)


  fd1 <-
  plotly::plot_ly(
    x = Flood.duration.df$flood_dur,
    y = Flood.duration.df$count,
    type = "bar",
    hoverinfo = "text",
    hovertext = paste("coiids: ", stringr::str_wrap(Flood.duration.df$coiids, 40))
  ) |>  plotly::layout(
    title = "Flood dur. (# components)",
    xaxis = list(title = "Flooding duration"),
    yaxis = list(title = "# of components"),
    margin = list(t = 100)
  )


fd2 <-
  plotly::plot_ly(
    x = Flood.duration.df$flood_dur,
    y = Flood.duration.df$acres,
    name = "Flood dur. (acres)",
    type = "bar",
    hoverinfo = "text",
    hovertext = paste("coiids: ", stringr::str_wrap(Flood.duration.df$coiids, 40))
  ) |>  plotly::layout(
    title = "Flood dur. (# of acres)",
    xaxis = list(title = "Flooding duration"),
    yaxis = list(title = "acres"),
    margin = list(t = 100)
  )

manipulateWidget::combineWidgets(fd1,
                                 fd2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

  

}
```

**Flooding duration acreage weighted summary statistics**
```{r}
if (all(is.na(EDIT_updates_filtered$flood_dur))) {print("No data populated in NASIS for this field.")
  
} else{
  
  EDIT_updates_filtered |>  dplyr::select(coiid, flood_dur, comp_acres) |>  dplyr::group_by(flood_dur) |>  
    dplyr::summarise(acres = sum(comp_acres),  '# components' = dplyr::n()) |>  dplyr::arrange(desc(acres)) |>  as.data.frame()

}
```

**Flooding duration acreage weighted statistics.**

Actual low (5%) and actual high (95%). Representative low (20%) and representative high (80%).
```{r}
if (all(is.na(EDIT_updates_filtered$flood_dur))) {print("No data populated in NASIS for this field.")
  
} else{
  
    expanded_flood_dur <- rep(EDIT_updates_filtered$flood_dur, 
                               plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit,
                                               accuracy = 1, f = round))
    
    expanded_flood_dur <- expanded_flood_dur[order(match(expanded_flood_dur, my_levels))]
  
    data.frame("5%" = expanded_flood_dur[ceiling(0.05 * length(expanded_flood_dur))],
               "20%" = expanded_flood_dur[ceiling(0.20 * length(expanded_flood_dur))],
               "80%" = expanded_flood_dur[ceiling(0.80 * length(expanded_flood_dur))],
             "95%" = expanded_flood_dur[ceiling(0.95 * length(expanded_flood_dur))],
             check.names = FALSE)

}

```

#### **Ponding freq.**

```{r, results='asis'}
EDIT_updates_filtered$pond_freq <- ifelse(EDIT_updates_filtered$pond_freq == "", "none", EDIT_updates_filtered$pond_freq)


if (all(is.na(EDIT_updates_filtered$pond_freq))) {print("No data populated in NASIS for this field.")
  
} else{
  
  my_levels <- c(
    "none",
    "rare",
    "occasional",
    "frequent",
    "common"
  )
    
pond.freq.df <- EDIT_updates_filtered |>  dplyr::select(coiid, pond_freq, comp_acres)  |>  dplyr::group_by(pond_freq) |>  dplyr::summarise(count = dplyr::n(), acres = sum(comp_acres), coiids = toString(coiid)) |>  dplyr::ungroup() 

pond.freq.df$pond_freq <- factor(pond.freq.df$pond_freq, levels = my_levels)

  
pf1 <-
  plotly::plot_ly(
    x = pond.freq.df$pond_freq,
    y = pond.freq.df$count,
    type = "bar",
    hoverinfo = "text",
    hovertext = paste("coiids: ", stringr::str_wrap(pond.freq.df$coiids, 40))
  ) |>  plotly::layout(
    title = "Pond freq. (# components)",
    xaxis = list(title = "Ponding frequency"),
    yaxis = list(title = "# of components"),
    margin = list(t = 100)
  )


pf2 <-
  plotly::plot_ly(
    x = pond.freq.df$pond_freq,
    y = pond.freq.df$acres,
    name = "Pond freq. (acres)",
    type = "bar",
    hoverinfo = "text",
    hovertext = paste("coiids: ", stringr::str_wrap(pond.freq.df$coiids, 40))
  ) |>  plotly::layout(
    title = "Pond freq. (# of acres)",
    xaxis = list(title = "Ponding frequency"),
    yaxis = list(title = "acres"),
    margin = list(t = 100)
  )

manipulateWidget::combineWidgets(pf1,
                                 pf2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Ponding frequency acreage weighted summary statistics**
```{r}
if (all(is.na(EDIT_updates_filtered$pond_freq))) {print("No data populated in NASIS for this field.")
  
} else{
  
  EDIT_updates_filtered |>  dplyr::select(coiid, pond_freq, comp_acres) |>  dplyr::group_by(pond_freq) |>  
    dplyr::summarise(acres = sum(comp_acres),  '# components' = dplyr::n()) |>  dplyr::arrange(desc(acres)) |>  as.data.frame()

}
```

**Ponding frequency acreage weighted statistics.**

Actual low (5%) and actual high (95%). Representative low (20%) and representative high (80%).
```{r}
if (all(is.na(EDIT_updates_filtered$pond_freq))) {print("No data populated in NASIS for this field.")
  
} else{
  
    expanded_pond_freq <- rep(EDIT_updates_filtered$pond_freq, 
                               plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit,
                                               accuracy = 1, f = round))
    
    expanded_pond_freq <- expanded_pond_freq[order(match(expanded_pond_freq, my_levels))]
  
    data.frame("5%" = expanded_pond_freq[ceiling(0.05 * length(expanded_pond_freq))],
               "20%" = expanded_pond_freq[ceiling(0.20 * length(expanded_pond_freq))],
               "80%" = expanded_pond_freq[ceiling(0.80 * length(expanded_pond_freq))],
             "95%" = expanded_pond_freq[ceiling(0.95 * length(expanded_pond_freq))],
             check.names = FALSE)

}

```

#### **Ponding duration**

Put "--" for duration if frequency is "none"

```{r}
EDIT_updates_filtered$pond_dur <- ifelse(EDIT_updates_filtered$pond_dur == "", "none", EDIT_updates_filtered$pond_dur)

if (all(is.na(EDIT_updates_filtered$pond_dur))) {print("No data populated in NASIS for this field.")
  
} else{
  
  my_levels <- c(
    "none",
    "very brief",
    "brief",
    "long",
    "very long"
  )
  
  pond.duration.df <- EDIT_updates_filtered |>  dplyr::select(coiid, pond_dur, comp_acres) |>  
    dplyr::group_by(pond_dur) |>  dplyr::summarise(count = dplyr::n(), acres = sum(comp_acres),
                       coiids = toString(coiid)) |>  dplyr::ungroup() 
  
  pond.duration.df$pond_dur <- factor(pond.duration.df$pond_dur, levels = my_levels)
  
  pd1 <-
  plotly::plot_ly(
    x = pond.duration.df$pond_dur,
    y = pond.duration.df$count,
    type = "bar",
    hoverinfo = "text",
    hovertext = paste("coiids: ", stringr::str_wrap(pond.duration.df$coiids, 40))
  ) |>  plotly::layout(
    title = "Pond dur. (# components)",
    xaxis = list(title = "Ponding duration"),
    yaxis = list(title = "# of components"),
    margin = list(t = 100)
  )


  pd2 <-
  plotly::plot_ly(
    x = pond.duration.df$pond_dur,
    y = pond.duration.df$acres,
    name = "Pond dur. (acres)",
    type = "bar",
    hoverinfo = "text",
    hovertext = paste("coiids: ", stringr::str_wrap(pond.duration.df$coiids, 40))
  ) |>  plotly::layout(
    title = "Pond dur. (# of acres)",
    xaxis = list(title = "Ponding duration"),
    yaxis = list(title = "acres"),
    margin = list(t = 100)
  )

manipulateWidget::combineWidgets(pd1,
                                 pd2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))



}
```

**Ponding duration acreage weighted summary statistics**
```{r}
if (all(is.na(EDIT_updates_filtered$pond_dur))) {print("No data populated in NASIS for this field.")
  
} else{
  
  EDIT_updates_filtered |>  dplyr::select(coiid, pond_dur, comp_acres) |>  dplyr::group_by(pond_dur) |>  
    dplyr::summarise(acres = sum(comp_acres),  '# components' = dplyr::n()) |>  dplyr::arrange(desc(acres)) |>  as.data.frame()

}
```

**Ponding duration acreage weighted statistics.**

5th and 95th percentiles should be used for 'low (actual)' and 'high (actual)'. The 20th and 80th percentiles should be used for the 'low (representative)' and 'high (representative)'. 
```{r}
if (all(is.na(EDIT_updates_filtered$pond_dur))) {print("No data populated in NASIS for this field.")
  
} else{
  
    expanded_pond_dur <- rep(EDIT_updates_filtered$pond_dur, 
                               plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit,
                                               accuracy = 1, f = round))
    
    expanded_pond_dur <- expanded_pond_dur[order(match(expanded_pond_dur, my_levels))]
  
    data.frame("5%" = expanded_pond_dur[ceiling(0.05 * length(expanded_pond_dur))],
               "20%" = expanded_pond_dur[ceiling(0.20 * length(expanded_pond_dur))],
               "80%" = expanded_pond_dur[ceiling(0.80 * length(expanded_pond_dur))],
             "95%" = expanded_pond_dur[ceiling(0.95 * length(expanded_pond_dur))],
             check.names = FALSE)

}

```

#### **Elevation**

Elevation prep code
```{r, message=FALSE}
if (all(is.na(EDIT_updates_filtered$elev_h_ft)) &
    all(is.na(EDIT_updates_filtered$elev_l_ft))) {print("No data populated in NASIS for this field.")
  
} else{

# Define bin width and round by measures
  
bin_width <- 250
round_by <- 500  

# Default dataframe
  
elev.df <-
  EDIT_updates_filtered |>  dplyr::select(coiid, elev_h_ft, elev_l_ft, comp_acres) |> 
  tidyr::pivot_longer(
    names_to = "elev",
    values_to = "value",
    cols = c("elev_h_ft", "elev_l_ft")) |> 
  dplyr::rename(acres = comp_acres)

# Sequence for axes

my_seq <- seq(plyr::round_any(min(EDIT_updates_filtered$elev_l_ft, na.rm = TRUE), round_by, f = floor),
  plyr::round_any(max(EDIT_updates_filtered$elev_h_ft, na.rm = TRUE), round_by, f = ceiling), bin_width)

my_seq <- if(min(my_seq) == min(EDIT_updates_filtered$elev_l_ft, na.rm = TRUE) &
             min(EDIT_updates_filtered$elev_l_ft, na.rm = TRUE) - bin_width >= 0){
  seq(plyr::round_any(min(EDIT_updates_filtered$elev_l_ft, na.rm = TRUE), round_by, f = floor) - bin_width,
      plyr::round_any(max(EDIT_updates_filtered$elev_h_ft, na.rm = TRUE), round_by, f = ceiling), bin_width)
} else{
  
  my_seq  
  
}

}

```


```{r, warning=FALSE, message=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$elev_h_ft))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

el_h1 <- ggplot2::ggplot(elev.df |>  dplyr::filter(elev == "elev_h_ft"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Elevation high") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Elevation (ft.)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
                              breaks = my_seq[seq(1, length(my_seq), by = 2)])

# Convert histogram to plotly

el_h1 <- plotly::ggplotly(el_h1, tooltip = "text")

# Acreage histogram

el_h2 <- ggplot2::ggplot(elev.df |>  dplyr::filter(elev == "elev_h_ft"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Elevation high") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Elevation (ft.)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  breaks = my_seq[seq(1, length(my_seq), by = 2)]
  )

# COnvert acreage histogram to plotly

el_h2 <- plotly::ggplotly(el_h2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(el_h1,
                                 el_h2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))


}

```

**Elevation high acreage weighted 95th percentile**  -  use as 'high (actual)'

Round elevation in a manner consistent with your data. For many situations, it will likely be to the hundreds place. 
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$elev_h_ft))) {print("No data populated in NASIS for this field.")
  
} else{
  
  elev_h_stats <- rep(EDIT_updates_filtered$elev_h_ft, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                accuracy = 1, f = round)) |> sort(na.last = NA)
  
  elev_h_stats |> quantile(probs = c(0.95), na.rm = TRUE, type = 1)

}

```

**Elevation high acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$elev_h_ft))) {print("No data populated in NASIS for this field.")
  
} else{

  summary(elev_h_stats)

}
```

```{r, warning=FALSE, message=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$elev_l_ft))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

el_l1 <- ggplot2::ggplot(elev.df |>  dplyr::filter(elev == "elev_l_ft"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Elevation low") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Elevation (ft.)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  breaks = my_seq[seq(1, length(my_seq), by = 2)])

# Convert histogram to plotly

el_l1 <- plotly::ggplotly(el_l1, tooltip = "text")

# Acreage weighted histogram

el_l2 <- ggplot2::ggplot(elev.df |>  dplyr::filter(elev == "elev_l_ft"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Elevation low") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Elevation (ft.)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  breaks = my_seq[seq(1, length(my_seq), by = 2)])

# Convert to plotly

el_l2 <- plotly::ggplotly(el_l2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(el_l1,
                                 el_l2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```
 
**Elevation low acreage weighted 5th percentile** - use as 'low (actual)'
```{r}

if (all(is.na(EDIT_updates_filtered$elev_l_ft))) {print("No data populated in NASIS for this field.")
  
} else{
  
    elev_l_stats <- rep(EDIT_updates_filtered$elev_l_ft, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                          accuracy = 1, f = round)) |> sort(na.last = NA)
    
    elev_l_stats |>  quantile(probs = c(0.05), na.rm = TRUE, type = 1)

}

```

**Elevation low acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$elev_l_ft))) {print("No data populated in NASIS for this field.")
  
} else{

  summary(elev_l_stats)

}

```


```{r, warning=FALSE, message=FALSE}

if (all(is.na(EDIT_updates_filtered$elev_l_ft & EDIT_updates_filtered$elev_h_ft))) {print("No data populated in NASIS for this field.")
  
} else{
  
el_r1 <- ggplot2::ggplot(elev.df |>  dplyr::filter(elev %in% c("elev_h_ft", "elev_l_ft")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Elevation representative") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Elevation (ft.)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  breaks = my_seq[seq(1, length(my_seq), by = 2)])

# Convert histogram to plotly

el_r1 <- plotly::ggplotly(el_r1, tooltip = "text")

# Acreage weighted histogram

el_r2 <- ggplot2::ggplot(elev.df |>  dplyr::filter(elev %in% c("elev_h_ft", "elev_l_ft")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Elevation representative") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Elevation (ft.)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  breaks = my_seq[seq(1, length(my_seq), by = 2)])

# Convert to plotly

el_r2 <- plotly::ggplotly(el_r2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(el_r1,
                                 el_r2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))


}

```

**Elevation representative - combined component high/low 20th and 80th percentile** - use as 'low (representative)' & 'high (representative)' 
```{r}
if (all(is.na(EDIT_updates_filtered$elev_l_ft & EDIT_updates_filtered$elev_h_ft))) {print("No data populated in NASIS for this field.")
  
} else{
  
  elev_r_stats <- rep(elev.df$value, plyr::round_any(elev.df$acres/comp_acreage_unit, 
                            accuracy = 1, f = round)) |> sort(na.last = NA)
  
  elev_r_stats |>  quantile(c(0.2, 0.8), na.rm = TRUE, type = 1)

}

```

**Elevation representative acreage weighted summary statistics**
```{r}
if (all(is.na(EDIT_updates_filtered$elev_l_ft & EDIT_updates_filtered$elev_h_ft))) {print("No data populated in NASIS for this field.")
  
} else{

  summary(elev_r_stats)

}

```

#### **Slope**

Slope prep code
```{r, message=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$slope_h)) & 
    all(is.na(EDIT_updates_filtered$slope_l))) {print("No data populated in NASIS for this field.")
  
} else{

# Define bin width and round by measures

bin_width <- 5
round_by <- 5

# Default dataframe

slope.df <-
  EDIT_updates_filtered |>  dplyr::select(coiid, slope_h, slope_l, comp_acres) |> 
  tidyr::pivot_longer(
    names_to = "slope",
    values_to = "value",
    cols = c("slope_h", "slope_l")) |> 
  dplyr::rename(acres = comp_acres) 

# Sequence for axes

my_seq <- seq(plyr::round_any(min(EDIT_updates_filtered$slope_l, na.rm = TRUE), round_by, f = floor),
  plyr::round_any(max(EDIT_updates_filtered$slope_h, na.rm = TRUE), round_by, f = ceiling), bin_width)

my_seq <- if(min(my_seq) == min(EDIT_updates_filtered$slope_l, na.rm = TRUE) &
             min(EDIT_updates_filtered$slope_l, na.rm = TRUE) - bin_width >= 0){
  seq(plyr::round_any(min(EDIT_updates_filtered$slope_l, na.rm = TRUE), round_by, f = floor) - bin_width,
      plyr::round_any(max(EDIT_updates_filtered$slope_h, na.rm = TRUE), round_by, f = ceiling), bin_width)
} else{
  
  my_seq   
  
}

}
```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$slope_h))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

slope_h1 <- ggplot2::ggplot(slope.df |>  dplyr::filter(slope == "slope_h"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Slope high") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Slope (%)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  breaks = my_seq[seq(1, length(my_seq), by = 2)])

# Convert histogram to plotly

slope_h1 <- plotly::ggplotly(slope_h1, tooltip = "text")

# Acreage weighted histogram

slope_h2 <- ggplot2::ggplot(slope.df |>  dplyr::filter(slope == "slope_h"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Slope high") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Slope (%)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  breaks = my_seq[seq(1, length(my_seq), by = 2)])

# Convert to plotly

slope_h2 <- plotly::ggplotly(slope_h2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(slope_h1,
                                 slope_h2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Slope high acreage weighted 95th percentile** -  use as 'high (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$slope_h))) {print("No data populated in NASIS for this field.")
  
} else{

  slope_h_sum_stats <- rep(EDIT_updates_filtered$slope_h, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                               accuracy = 1, f = round)) |> sort(na.last = NA)
  
  slope_h_sum_stats |>  quantile(probs = c(0.95), na.rm = TRUE, type = 1)

}

```

**Slope high acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$slope_h))) {print("No data populated in NASIS for this field.")
  
} else{
  
summary(slope_h_sum_stats)

}
```

```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$slope_l))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

slope_l1 <- ggplot2::ggplot(slope.df |>  dplyr::filter(slope == "slope_l"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Slope low") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Slope (ft.)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  breaks = my_seq[seq(1, length(my_seq), by = 2)])

# Convert histogram to plotly

slope_l1 <- plotly::ggplotly(slope_l1, tooltip = "text")

# Acreage weighted histogram

slope_l2 <- ggplot2::ggplot(slope.df |>  dplyr::filter(slope == "slope_l"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Slope low") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Slope (ft.)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  breaks = my_seq[seq(1, length(my_seq), by = 2)])


# Convert to plotly

slope_l2 <- plotly::ggplotly(slope_l2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(slope_l1,
                                 slope_l2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Slope low acreage weighted 5th percentile** -  use as 'low (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$slope_l))) {print("No data populated in NASIS for this field.")
  
} else{
  
  slope_l_sum_stats <- rep(EDIT_updates_filtered$slope_l, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                            accuracy = 1, f = round)) |> sort(na.last = NA)
  
  
  slope_l_sum_stats |>  quantile(probs = c(0.05), na.rm = TRUE, type = 1)

}

```

**Slope low acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$slope_l))) {print("No data populated in NASIS for this field.")
  
} else{
  
  summary(slope_l_sum_stats)

}
```

```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$slope_h)) & all(is.na(EDIT_updates_filtered$slope_l))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

slope_r1 <- ggplot2::ggplot(slope.df |>  dplyr::filter(slope %in% c("slope_h", "slope_l")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Slope representative") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Slope (%)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  breaks = my_seq[seq(1, length(my_seq), by = 2)])

# Convert histogram to plotly

slope_r1 <- plotly::ggplotly(slope_r1, tooltip = "text")

# Acreage weighted histogram

slope_r2 <- ggplot2::ggplot(slope.df |>  dplyr::filter(slope %in% c("slope_h", "slope_l")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Slope representative") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Slope (%)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  breaks = my_seq[seq(1, length(my_seq), by = 2)])

# Convert to plotly

slope_r2 <- plotly::ggplotly(slope_r2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(slope_r1,
                                 slope_r2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Slope representative - combined component high/low 20th and 80th percentile** - use as 'low (representative)' & 'high (representative)' 
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$slope_h)) & all(is.na(EDIT_updates_filtered$slope_l))) {print("No data populated in NASIS for this field.")
  
} else{
  
  slope_r_sum_stats <- rep(slope.df$value, plyr::round_any(slope.df$acres/comp_acreage_unit, 
                                accuracy = 1, f = round)) |> sort(na.last = NA)
  
  slope_r_sum_stats |>  quantile(c(0.2, 0.8), na.rm = TRUE)

}

```

**Slope representative acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$slope_h)) & all(is.na(EDIT_updates_filtered$slope_l))) {print("No data populated in NASIS for this field.")
  
} else{
  
  summary(slope_r_sum_stats)

}
```

#### **Ponding depth**

One thing to clarify about ponding depth - this is a measure of how deep the ponding is above the soil surface. If ecosite does not have a ponding depth, uncheck the box. 

Ponding depth prep code
```{r, message=FALSE}
if (all(is.na(EDIT_updates_filtered$pond_depth_h))  & all(is.na(EDIT_updates_filtered$pond_depth_l))) {print("No data populated in NASIS for this field.")
  
} else{
  
# Define bin width and round by measures

bin_width <- 2
round_by <- 2

# Default dataframe

pond_depth.df <-
  EDIT_updates_filtered |>  dplyr::select(coiid, pond_depth_l, pond_depth_h, comp_acres) |> 
  tidyr::pivot_longer(
    names_to = "pond_depth",
    values_to = "value",
    cols = c("pond_depth_l", "pond_depth_h")) |> 
  dplyr::rename(acres = comp_acres)

# Sequence for axes

my_seq <- seq(plyr::round_any(min(EDIT_updates_filtered$pond_depth_l, na.rm = TRUE), round_by, f = floor),
  plyr::round_any(max(EDIT_updates_filtered$pond_depth_h, na.rm = TRUE), round_by, f = ceiling), bin_width)

my_seq <- if(min(my_seq) == min(EDIT_updates_filtered$pond_depth_l, na.rm = TRUE) &
             min(EDIT_updates_filtered$pond_depth_l, na.rm = TRUE) - bin_width >= 0){
  seq(plyr::round_any(min(EDIT_updates_filtered$pond_depth_l, na.rm = TRUE), round_by, f = floor) - bin_width,
      plyr::round_any(max(EDIT_updates_filtered$pond_depth_h, na.rm = TRUE), round_by, f = ceiling), bin_width)
} else{
  
  my_seq   
  
}

}
```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$pond_depth_h))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

pond_depth_h1 <- ggplot2::ggplot(pond_depth.df |>  dplyr::filter(pond_depth == "pond_depth_h"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Ponding depth high") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Ponding depth (inches)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

pond_depth_h1 <- plotly::ggplotly(pond_depth_h1, tooltip = "text")

# Acreage weighted histogram

pond_depth_h2 <- ggplot2::ggplot(pond_depth.df |>  dplyr::filter(pond_depth == "pond_depth_h"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Ponding depth high") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Ponding depth (inches)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

pond_depth_h2 <- plotly::ggplotly(pond_depth_h2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(pond_depth_h1,
                                 pond_depth_h2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

NAs in ponding depth likely mean that no ponding was observed. NA's are not represented in the figures above. Please observe the table below to determine if NAs exist in your dataset.
```{r}
if (all(is.na(EDIT_updates_filtered$pond_depth_h))) {print("No data populated in NASIS for this field.")
  
} else{
  
  data.frame('# components NA' = sum(is.na(EDIT_updates_filtered$pond_depth_h)),
             '% components NA' = 100*sum(is.na(EDIT_updates_filtered$pond_depth_h))/length(EDIT_updates_filtered$pond_depth_h),
             check.names = FALSE)

  
}
```

**Ponding depth high acreage weighted 95th percentile** -  use as 'high (actual)'. This value may be NA.  

The percentile calculation for ponding depth is performed differently because NAs in the ponding depth likely mean no ponding was observed. For that reason, we will consider NAs to be an ordinal value that is lower than all other quantitative values. 
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$pond_depth_h))) {print("No data populated in NASIS for this field.")
  
} else{
  
    pond_depth_na_h_rem_expanded <- c(rep(EDIT_updates_filtered$pond_depth_h, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, accuracy = 1, f = round))) |> sort(na.last = FALSE)

   data.frame("95%" = pond_depth_na_h_rem_expanded[ceiling(0.95 * length(pond_depth_na_h_rem_expanded))], 
             check.names = FALSE)
  
}

```

**Ponding depth high acreage weighted summary statistics** - Summary statistics are calculated using numeric values (NA values omitted). The combined acreage of components with an NA value is listed. 
```{r}

if (all(is.na(EDIT_updates_filtered$pond_depth_h))) {print("No data populated in NASIS for this field. For ponding, this likely means no ponding was observed.")
  
} else{
  
  summary(pond_depth_na_h_rem_expanded, na.rm = TRUE)

}
```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$pond_depth_l))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

pond_depth_l1 <- ggplot2::ggplot(pond_depth.df |>  dplyr::filter(pond_depth == "pond_depth_l"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Ponding depth low") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Ponding depth (inches)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

pond_depth_l1 <- plotly::ggplotly(pond_depth_l1, tooltip = "text")

# Acreage weighted histogram

pond_depth_l2 <- ggplot2::ggplot(pond_depth.df |>  dplyr::filter(pond_depth == "pond_depth_l"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Ponding depth low") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Ponding depth (inches)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

pond_depth_l2 <- plotly::ggplotly(pond_depth_l2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(pond_depth_l1,
                                 pond_depth_l2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

NAs in ponding depth likely mean that no ponding was observed. NA's are not represented in the figures above. Please observe the table below to determine if NAs exist in your dataset.
```{r}
if (all(is.na(EDIT_updates_filtered$pond_depth_l))) {print("No data populated in NASIS for this field.")
  
} else{
  
  data.frame('# components NA' = sum(is.na(EDIT_updates_filtered$pond_depth_l)),
             '% components NA' = 100*sum(is.na(EDIT_updates_filtered$pond_depth_l))/length(EDIT_updates_filtered$pond_depth_l),
             check.names = FALSE)
}

```

**Ponding depth low acreage weighted 5th percentile** -  use as 'low (actual)'. This value may be NA.  

The percentile calculation for ponding depth is performed differently because NAs in ponding depth likely mean no ponding was observed. For that reason, we will consider NAs to be an ordinal value that is less than all other quantitative values.
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$pond_depth_l))) {print("No data populated in NASIS for this field.")
  
} else{
  
    pond_depth_na_l_rem_expanded <- c(rep(EDIT_updates_filtered$pond_depth_l, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, accuracy = 1, f = round))) |> sort(na.last = FALSE)

   data.frame("5%" = pond_depth_na_l_rem_expanded[ceiling(0.05 * length(pond_depth_na_l_rem_expanded))], 
             check.names = FALSE)
  
}

```

**Ponding depth low acreage weighted summary statistics** - Summary statistics are calculated using numeric values (NA values omitted). The combined acreage of components with an NA value is listed.
```{r}

if (all(is.na(EDIT_updates_filtered$pond_depth_l))) {print("No data populated in NASIS for this field. For ponding, this likely means no ponding was observed.")
  
} else{
  
summary(pond_depth_na_l_rem_expanded)

}
```



```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$pond_depth_l & EDIT_updates_filtered$pond_depth_h))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

pond_depth_r1 <- ggplot2::ggplot(pond_depth.df |>  dplyr::filter(pond_depth %in% c("pond_depth_l", "pond_depth_h")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Ponding depth representative") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Ponding depth (inches)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

pond_depth_r1 <- plotly::ggplotly(pond_depth_r1, tooltip = "text")

# Acreage weighted histogram

pond_depth_r2 <- ggplot2::ggplot(pond_depth.df |>  dplyr::filter(pond_depth %in% c("pond_depth_l", "pond_depth_h")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Ponding depth representative") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Ponding depth (inches)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

pond_depth_r2 <- plotly::ggplotly(pond_depth_r2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(pond_depth_r1,
                                 pond_depth_r2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

NAs in ponding depth likely mean that no ponding was observed. NA's are not represented in the figures above. Please observe the table below to determine if NAs exist in your dataset.
```{r}
if (all(is.na(EDIT_updates_filtered$pond_depth_l & EDIT_updates_filtered$pond_depth_h))) {print("No data populated in NASIS for this field.")
  
} else{
  
  data.frame('# components NA' = sum(is.na(EDIT_updates_filtered$pond_depth_h)) + sum(is.na(EDIT_updates_filtered$pond_depth_h)),
             '% components NA' = 100*(sum(is.na(EDIT_updates_filtered$pond_depth_h)) + sum(is.na(EDIT_updates_filtered$pond_depth_h)))/
               (length(EDIT_updates_filtered$pond_depth_h) * 2), check.names = FALSE)
  
}

```

**Ponding depth representative - combined component high/low 20th and 80th percentile** - use as 'low (representative)' & 'high (representative)'. This value may be NA.  

The percentile calculation for ponding depth is performed differently because NAs in ponding depth likely mean no ponding was observed. For that reason, we will consider NAs to be an ordinal value that is less than all other quantitative values.
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$pond_depth_l & EDIT_updates_filtered$pond_depth_h))) {print("No data populated in NASIS for this field.")
  
} else{
  
  pond_depth_r_sum_stats <- rep(pond_depth.df$value, plyr::round_any(pond_depth.df$acres/comp_acreage_unit, accuracy = 1, f = round)) |> sort(na.last = FALSE)

  data.frame("20%" = pond_depth_r_sum_stats[ceiling(0.2 * length(pond_depth_r_sum_stats))],
             "80%" = pond_depth_r_sum_stats[ceiling(0.8 * length(pond_depth_r_sum_stats))],
             check.names = FALSE)
  
}

```

**Ponding depth representative acreage weighted summary statistics** - Summary statistics are calculated using numeric values (NA values omitted). The combined acreage of components with an NA value is listed.
```{r}

if (all(is.na(EDIT_updates_filtered$pond_depth_l & EDIT_updates_filtered$pond_depth_h))) {print("No data populated in NASIS for this field. For ponding, this likely means no ponding was observed.")
  
} else{
  
summary(pond_depth_r_sum_stats)

}
```

#### **Water table depth**

Water table depth prep code
```{r, message=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$water_table_h_in)) & all(is.na(EDIT_updates_filtered$water_table_l_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
# Define bin width and round by measures

bin_width <- 10
round_by <- 10

# Default dataframe

water_table.df <-
  EDIT_updates_filtered |>  dplyr::select(coiid, water_table_l_in, water_table_h_in, comp_acres) |> 
  tidyr::pivot_longer(
    names_to = "water_table",
    values_to = "value",
    cols = c("water_table_l_in", "water_table_h_in")) |> 
  dplyr::rename(acres = comp_acres)

# Sequence for axes

my_seq <- seq(plyr::round_any(min(EDIT_updates_filtered$water_table_l_in, na.rm = TRUE), round_by, f = floor),
  plyr::round_any(max(EDIT_updates_filtered$water_table_h_in, na.rm = TRUE), round_by, f = ceiling), bin_width)

my_seq <- if(min(my_seq) == min(EDIT_updates_filtered$water_table_l_in, na.rm = TRUE) &
             min(EDIT_updates_filtered$water_table_l_in, na.rm = TRUE) - bin_width >= 0){
  seq(plyr::round_any(min(EDIT_updates_filtered$water_table_l_in, na.rm = TRUE), round_by, f = floor) - bin_width,
      plyr::round_any(max(EDIT_updates_filtered$water_table_h_in, na.rm = TRUE), round_by, f = ceiling), bin_width)
} else{
  
  my_seq   
  
}

}
```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$water_table_h_in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

water_table_h1 <- ggplot2::ggplot(water_table.df |>  dplyr::filter(water_table == "water_table_h_in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Water table high") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Water table (inches)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))
  
# Convert histogram to plotly

water_table_h1 <- plotly::ggplotly(water_table_h1, tooltip = "text")

# Acreage weighted histogram

water_table_h2 <- ggplot2::ggplot(water_table.df |>  dplyr::filter(water_table == "water_table_h_in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Water table high") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Water table (inches)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

water_table_h2 <- plotly::ggplotly(water_table_h2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(water_table_h1,
                                 water_table_h2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

NAs in water table likely mean that no water table was observed. NA's are not represented in the figures above. Please observe the table below to understand the relative acreage classified as NA. 
```{r}
if (all(is.na(EDIT_updates_filtered$water_table_h_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  data.frame('# components NA' = sum(is.na(EDIT_updates_filtered$water_table_h_in)),
             '% components NA' = 100*sum(is.na(EDIT_updates_filtered$water_table_h_in))/length(EDIT_updates_filtered$water_table_h_in),
             check.names = FALSE) 
  
}
```

**Water table high acreage weighted 95th percentile** -  use as 'high (actual)'. This value may be NA.  

The percentile calculation for water table is performed differently because NAs in the water table likely mean no water table was observed. For that reason, we will consider NAs to be an ordinal value that is deeper than all other quantitative values. 
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$water_table_h_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
    water_table_na_h_rem_expanded <- c(rep(EDIT_updates_filtered$water_table_h_in, EDIT_updates_filtered$comp_acres/comp_acreage_unit)) |> sort(na.last = TRUE)

   data.frame("95%" = water_table_na_h_rem_expanded[ceiling(0.95 * length(water_table_na_h_rem_expanded))], 
             check.names = FALSE)

}

```

**Water table high acreage weighted summary statistics** - Summary statistics are calculated using numeric values (NA values omitted). The combined acreage of components with an NA value is listed.
```{r}

if (all(is.na(EDIT_updates_filtered$water_table_h_in))) {print("No data populated in NASIS for this field. For water table, this likely means no water table was observed.")
  
} else{
  
 summary(water_table_na_h_rem_expanded, na.rm = TRUE)

}
```

```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$water_table_l_in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

water_table_l1 <- ggplot2::ggplot(water_table.df |>  dplyr::filter(water_table == "water_table_l_in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Water table low") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Water table (inches)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

water_table_l1 <- plotly::ggplotly(water_table_l1, tooltip = "text")

# Acreage weighted histogram

water_table_l2 <- ggplot2::ggplot(water_table.df |>  dplyr::filter(water_table == "water_table_l_in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Water table low") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Water table (inches)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

water_table_l2 <- plotly::ggplotly(water_table_l2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(water_table_l1,
                                 water_table_l2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

NA's in water table likely mean that no water table was observed. NA's are not represented in the figures above. Please observe the table below to understand the relative acreage classified as NA. 
```{r}
if (all(is.na(EDIT_updates_filtered$water_table_l_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  data.frame('# components NA' = sum(is.na(EDIT_updates_filtered$water_table_l_in)),
             '% components NA' = 100*sum(is.na(EDIT_updates_filtered$water_table_l_in))/length(EDIT_updates_filtered$water_table_l_in),
             check.names = FALSE)

}

```

**Water table low acreage weighted 5th percentile** -  use as 'low (actual)'. This value may be NA.  

The percentile calculation for water table is performed differently because NAs in the water table likely mean no water table was observed. For that reason, we will consider NAs to be an ordinal value that is deeper than all other quantitative values.
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$water_table_l_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
    water_table_na_l_rem_expanded <- rep(EDIT_updates_filtered$water_table_l_in, EDIT_updates_filtered$comp_acres/comp_acreage_unit) |> sort(na.last = TRUE)

    data.frame("5%" = water_table_na_l_rem_expanded[ceiling(0.05 * length(water_table_na_l_rem_expanded))], 
             check.names = FALSE)
  
}

```

**Water table low acreage weighted summary statistics** - Summary statistics are calculated using numeric values (NA values omitted). The combined acreage of components with an NA value is listed.
```{r}

if (all(is.na(EDIT_updates_filtered$water_table_l_in))) {print("No data populated in NASIS for this field. For water table, this likely means no water table was observed.")
  
} else{
  
summary(water_table_na_l_rem_expanded)

}
```

```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$water_table_l_in)) & all(is.na(EDIT_updates_filtered$water_table_h_in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

  water_table_r1 <-
    ggplot2::ggplot(water_table.df |>  dplyr::filter(water_table %in% c("water_table_l_in", "water_table_h_in")),
                    ggplot2::aes(x = value)) + ggplot2::geom_histogram(
                      ggplot2::aes(text = paste("coiid(s):", coiid)),
                      binwidth = bin_width,
                      center = min(my_seq) + bin_width / 2,
                      color = "black",
                      fill = "grey"
                    ) +
    ggplot2::ggtitle("Water table representative") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
    ggplot2::ylab("# of components") + ggplot2::xlab("Water table (inches)") +
    ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
                                n.breaks = length(my_seq))

# Convert histogram to plotly

water_table_r1 <- plotly::ggplotly(water_table_r1, tooltip = "text")

# Acreage weighted histogram

  water_table_r2 <-
    ggplot2::ggplot(water_table.df |>  dplyr::filter(water_table %in% c("water_table_l_in", "water_table_h_in")),
                    ggplot2::aes(x = value)) + ggplot2::geom_histogram(
                      ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres),
                      binwidth = bin_width,
                      center = min(my_seq) + bin_width / 2,
                      color = "black",
                      fill = "grey"
                    ) +
    ggplot2::ggtitle("Water table representative") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
    ggplot2::ylab("# of acres") + ggplot2::xlab("Water table (inches)") +
    ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
                                n.breaks = length(my_seq))

# Convert to plotly

water_table_r2 <- plotly::ggplotly(water_table_r2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(water_table_r1,
                                 water_table_r2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

NA's in water table likely mean that no water table was observed. NA's are not represented in the figures above. Please observe the table below to understand the relative acreage classified as NA. 
```{r}
if (all(is.na(EDIT_updates_filtered$water_table_l_in)) & all(is.na(EDIT_updates_filtered$water_table_h_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  data.frame('# components NA' = sum(is.na(EDIT_updates_filtered$water_table_l_in)) + sum(is.na(EDIT_updates_filtered$water_table_h_in)),
             '% components NA' = 100*(sum(is.na(EDIT_updates_filtered$water_table_h_in)) +
                                        sum(is.na(EDIT_updates_filtered$water_table_l_in)))/
               (length(EDIT_updates_filtered$water_table_l_in) * 2), check.names = FALSE)

}

```

**Water table representative - combined component high/low 20th and 80th percentile** - use as 'low (representative)' & 'high (representative)'. This value may be NA. 

The percentile calculation for water table is performed differently because NAs in the water table likely mean no water table was observed. For that reason, we will consider NAs to be an ordinal value that is deeper than all other quantitative values.
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$water_table_l_in)) & all(is.na(EDIT_updates_filtered$water_table_h_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  water_table_r_sum_stats <- rep(water_table.df$value, plyr::round_any(water_table.df$acres/comp_acreage_unit, accuracy = 1, f = round)) |> sort(na.last = TRUE)

  data.frame("20%" = water_table_r_sum_stats[ceiling(0.2 * length(water_table_r_sum_stats))],
             "80%" = water_table_r_sum_stats[ceiling(0.8 * length(water_table_r_sum_stats))],
             check.names = FALSE)
  
}

```

**Water table representative acreage weighted summary statistics** - Summary statistics are calculated using numeric values (NA values omitted). The combined acreage of components with an NA value is listed.
```{r}

if (all(is.na(EDIT_updates_filtered$water_table_l_in))) {print("No data populated in NASIS for this field. For water table, this likely means no water table was observed.")
  
} else{
  
summary(water_table_r_sum_stats)

}
```

#### **Aspect**

If site is not strongly associated with a particular aspect, select "not applicable"

I would suggest that we change aspect to be northness [cos(aspect)] and eastness [sin(aspect)]. These are more ecologically meaningful and would allow the statistics to be summarized. 

Im not aware of specific guidance on populating aspect data in EDIT. I personally would choose the aspects that you feel are representative. That would mean trimming values that dont seem like a core part of the distribution/concept. I am fairly liberal in saying that aspect is not applicable if I dont think I have the data to make a meaningful call. If there are only 2-3 components correlated to the ecosite, I would consider it pretty challenging to make a strong call unless they are tightly clustered. 
```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$aspect_rep))) {print("No data populated in NASIS for this field.")
  
} else{

# Define bin width and round by measures

bin_width <- 30
round_by <- 30

# Default dataframe

aspect.df <-
  EDIT_updates_filtered |>  dplyr::select(coiid, aspect_rep, comp_acres) |> 
  tidyr::pivot_longer(
    names_to = "aspect",
    values_to = "value",
    cols = c("aspect_rep")) |> 
  dplyr::rename(acres = comp_acres)

# Create component histogram

aspect_r1 <- ggplot2::ggplot(aspect.df |>  dplyr::filter(aspect == "aspect_rep"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Aspect") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Aspect (degrees)") +
  ggplot2::scale_x_continuous(limits = c(0, 360),
  breaks = seq(0,360, 30))

# Convert histogram to plotly

aspect_r1 <- plotly::ggplotly(aspect_r1, tooltip = "text")

# Sequence for axes

my_seq <- seq(plyr::round_any(min(EDIT_updates_filtered$aspect_rep, na.rm = TRUE), round_by, f = floor),
  plyr::round_any(max(EDIT_updates_filtered$aspect_rep, na.rm = TRUE), round_by, f = ceiling), bin_width)

my_seq <- if(min(my_seq) == min(EDIT_updates_filtered$aspect_rep, na.rm = TRUE) &
             min(EDIT_updates_filtered$aspect_rep, na.rm = TRUE) - bin_width >= 0){
  seq(plyr::round_any(min(EDIT_updates_filtered$aspect_rep, na.rm = TRUE), round_by, f = floor) - bin_width,
      plyr::round_any(max(EDIT_updates_filtered$aspect_rep, na.rm = TRUE), round_by, f = ceiling), bin_width)
} else{
  
  my_seq  
  
}

# Acreage weighted histogram

aspect_r2 <- ggplot2::ggplot(aspect.df |>  dplyr::filter(aspect == "aspect_rep"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Aspect") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Aspect (degrees)") +
  ggplot2::scale_x_continuous(limits = c(0, 360),
  breaks = seq(0,360, 30))

# Convert to plotly

aspect_r2 <- plotly::ggplotly(aspect_r2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(aspect_r1,
                                 aspect_r2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```


<center><h3>**Climate features tab:** </h3></center>

Populate climate variables in EDIT by selecting appropriate climate stations. If appropriate climate stations are not available, Mean Annual Precip. and Frost Free Days can be accessed from data mapunits.  

#### **Mean annual precipitation**

MAP prep code
```{r, message=FALSE}
if (all(is.na(EDIT_updates_filtered$map_h_in)) & all(is.na(EDIT_updates_filtered$map_l_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
# Define bin width and round by measures

bin_width <- 5
round_by <- 5

# Default dataframe

map.df <-
  EDIT_updates_filtered |>  dplyr::select(coiid, map_h_in, map_l_in, comp_acres) |> 
  tidyr::pivot_longer(
    names_to = "map",
    values_to = "value",
    cols = c("map_h_in", "map_l_in")) |> 
  dplyr::rename(acres = comp_acres)
  
# Sequence for axes

my_seq <- seq(plyr::round_any(min(EDIT_updates_filtered$map_l_in, na.rm = TRUE), round_by, f = floor),
  plyr::round_any(max(EDIT_updates_filtered$map_h_in, na.rm = TRUE), round_by, f = ceiling), bin_width)

my_seq <- if(min(my_seq) == min(EDIT_updates_filtered$map_l_in, na.rm = TRUE) &
             min(EDIT_updates_filtered$map_l_in, na.rm = TRUE) - bin_width >= 0){
  seq(plyr::round_any(min(EDIT_updates_filtered$map_l_in, na.rm = TRUE), round_by, f = floor) - bin_width,
      plyr::round_any(max(EDIT_updates_filtered$map_h_in, na.rm = TRUE), round_by, f = ceiling), bin_width)
} else{
  
  my_seq  
  
}

}
```


```{r, warning=FALSE, message=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$map_h_in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

map_h1 <- ggplot2::ggplot(map.df |>  dplyr::filter(map == "map_h_in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Mean Annual Precip. high") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Mean Annual Precip (inches)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

map_h1 <- plotly::ggplotly(map_h1, tooltip = "text")

# Acreage weighted histogram

map_h2 <- ggplot2::ggplot(map.df |>  dplyr::filter(map == "map_h_in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Mean Annual Precip. high") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Mean Annual Precip (inches)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

map_h2 <- plotly::ggplotly(map_h2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(map_h1,
                                 map_h2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**MAP high acreage weighted 95th percentile**  -  use as 'high (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$map_h_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  map_h_stats <- rep(EDIT_updates_filtered$map_h_in, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                            accuracy = 1, f = round)) |> sort(na.last = NA)
  
  map_h_stats |> quantile(probs = c(0.95), na.rm = TRUE, type = 1)

}

```

**MAP high acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$map_h_in))) {print("No data populated in NASIS for this field.")
  
} else{

summary(map_h_stats)

}
```

```{r, warning=FALSE, message=FALSE}

if (all(is.na(EDIT_updates_filtered$map_l_in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram
  
map_l1 <- ggplot2::ggplot(map.df |>  dplyr::filter(map == "map_l_in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Mean Annual Precip. low") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Mean Annual Precip. (inches)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

map_l1 <- plotly::ggplotly(map_l1, tooltip = "text")

# Acreage weighted histogram

map_l2 <- ggplot2::ggplot(map.df |>  dplyr::filter(map == "map_l_in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Mean Annual Precip. low") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Mean Annual Precip. (inches)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

map_l2 <- plotly::ggplotly(map_l2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(map_l1,
                                 map_l2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**MAP low acreage weighted 5th percentile** - use as 'low (actual)'
```{r}

if (all(is.na(EDIT_updates_filtered$map_l_in))) {print("No data populated in NASIS for this field.")
  
} else{
  

    map_l_stats <- rep(EDIT_updates_filtered$map_l_in, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                            accuracy = 1, f = round)) |> sort(na.last = NA)
    
    map_l_stats |>  quantile(probs = c(0.05), na.rm = TRUE, type = 1)

}

```

**MAP low acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$map_l_in))) {print("No data populated in NASIS for this field.")
  
} else{
  

summary(map_l_stats)

}

```


```{r, warning=FALSE, message=FALSE}
if (all(is.na(EDIT_updates_filtered$map_h_in)) & 
    all(is.na(EDIT_updates_filtered$map_l_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
# Create component histogram

map_r1 <- ggplot2::ggplot(map.df |>  dplyr::filter(map %in% c("map_h_in", "map_l_in") ), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Mean Annual Precip. representative") + 
  ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Mean Annual Precip. (inches)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

map_r1 <- plotly::ggplotly(map_r1, tooltip = "text")

# Acreage weighted histogram

map_r2 <- ggplot2::ggplot(map.df |>  dplyr::filter(map %in% c("map_h_in", "map_l_in") ), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Mean Annual Precip. representative") + 
  ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Mean Annual Precip. (inches)") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

map_r2 <- plotly::ggplotly(map_r2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(map_r1,
                                 map_r2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**MAP representative - combined component high/low acreage weighted 20th and 80th percentile** - use as 'low (representative)' & 'high (representative)' 
```{r}
if (all(is.na(EDIT_updates_filtered$map_h_in)) &
    all(is.na(EDIT_updates_filtered$map_l_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  map_r_stats <- rep(map.df$value, plyr::round_any(map.df$acres/comp_acreage_unit, 
                      accuracy = 1, f = round)) |> sort(na.last = NA)
  
  map_r_stats |>  quantile(c(0.2, 0.8), na.rm = TRUE, type = 1)

}

```

**MAP representative acreage weighted summary statistics**
```{r}
if (all(is.na(EDIT_updates_filtered$map_h_in)) &
    all(is.na(EDIT_updates_filtered$map_l_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
summary(map_r_stats)

}

```

#### **Frost Free Days**

Frost Free Days prep code
```{r, message=FALSE}

if (all(is.na(EDIT_updates_filtered$ffd_h)) & all(is.na(EDIT_updates_filtered$ffd_l))) {print("No data populated in NASIS for this field.")
  
} else{
  
# Define bin width and round by measures

bin_width <- 15
round_by <- 15

# Default dataframe

ffd.df <-
  EDIT_updates_filtered |>  dplyr::select(coiid, ffd_h, ffd_l, comp_acres) |> 
  tidyr::pivot_longer(
    names_to = "ffd",
    values_to = "value",
    cols = c("ffd_h", "ffd_l")) |> 
  dplyr::rename(acres = comp_acres)
  

# Sequence of axes

my_seq <- seq(plyr::round_any(min(EDIT_updates_filtered$ffd_l, na.rm = TRUE), round_by, f = floor),
  plyr::round_any(max(EDIT_updates_filtered$ffd_h, na.rm = TRUE), round_by, f = ceiling), bin_width)

my_seq <- if(min(my_seq) == min(EDIT_updates_filtered$ffd_l, na.rm = TRUE) &
             min(EDIT_updates_filtered$ffd_l, na.rm = TRUE) - bin_width >= 0){
  seq(plyr::round_any(min(EDIT_updates_filtered$ffd_l, na.rm = TRUE), round_by, f = floor) - bin_width,
      plyr::round_any(max(EDIT_updates_filtered$ffd_h, na.rm = TRUE), round_by, f = ceiling), bin_width)
} else{
  
  my_seq     
  
}

}
```


```{r, warning=FALSE, message=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$ffd_h))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

ffd_h1 <- ggplot2::ggplot(ffd.df |>  dplyr::filter(ffd == "ffd_h"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Frost Free Days high") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Frost Free Days") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

ffd_h1 <- plotly::ggplotly(ffd_h1, tooltip = "text")

# Acreage weighted histogram

ffd_h2 <- ggplot2::ggplot(ffd.df |>  dplyr::filter(ffd == "ffd_h"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Frost Free Days high") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Frost Free Days") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

ffd_h2 <- plotly::ggplotly(ffd_h2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(ffd_h1,
                                 ffd_h2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Frost Free Days high acreage weighted 95th percentile**  -  use as 'high (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$ffd_h))) {print("No data populated in NASIS for this field.")
  
} else{
  
  ffd_h_stats <- rep(EDIT_updates_filtered$ffd_h, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                          accuracy = 1, f = round)) |> sort(na.last = NA)
  
  ffd_h_stats |> quantile(probs = c(0.95), na.rm = TRUE, type = 1)

}

```

**Frost Free Days high acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$ffd_h))) {print("No data populated in NASIS for this field.")
  
} else{

summary(ffd_h_stats)
  
}
```

```{r, warning=FALSE, message=FALSE}

if (all(is.na(EDIT_updates_filtered$ffd_l))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

ffd_l1 <- ggplot2::ggplot(ffd.df |>  dplyr::filter(ffd == "ffd_l"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Frost Free Days low") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Frost Free Days") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

ffd_l1 <- plotly::ggplotly(ffd_l1, tooltip = "text")

# Acreage weighted histogram

ffd_l2 <- ggplot2::ggplot(ffd.df |>  dplyr::filter(ffd == "ffd_l"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Frost Free Days low") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Frost Free Days") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

ffd_l2 <- plotly::ggplotly(ffd_l2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(ffd_l1,
                                 ffd_l2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Frost Free Days low acreage weighted 5th percentile** - use as 'low (actual)'
```{r}

if (all(is.na(EDIT_updates_filtered$ffd_l))) {print("No data populated in NASIS for this field.")
  
} else{
  
    ffd_l_stats <- rep(EDIT_updates_filtered$ffd_l, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                    accuracy = 1, f = round)) |> sort(na.last = NA)
    
    ffd_l_stats |>  quantile(probs = c(0.05), na.rm = TRUE, type = 1)

}

```

**Frost Free Days low acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$ffd_l))) {print("No data populated in NASIS for this field.")
  
} else{
  
summary(ffd_l_stats)

}

```

```{r, warning=FALSE, message=FALSE}
if (all(is.na(EDIT_updates_filtered$ffd_h)) &
    all(is.na(EDIT_updates_filtered$ffd_l))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

ffd_r1 <- ggplot2::ggplot(ffd.df |>  dplyr::filter(ffd %in% c("ffd_h", "ffd_l")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Frost Free Days representitive") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Frost Free Days") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

ffd_r1 <- plotly::ggplotly(ffd_r1, tooltip = "text")

# Acreage weighted histogram

ffd_r2 <- ggplot2::ggplot(ffd.df |>  dplyr::filter(ffd %in% c("ffd_h", "ffd_l")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Frost Free Days representitive") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Frost Free Days") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

ffd_r2 <- plotly::ggplotly(ffd_r2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(ffd_r1,
                                 ffd_r2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Frost Free Days representative - combined component high/low acreage weighted 20th and 80th percentile** - use as 'low (representative)' & 'high (representative)' 
```{r}
if (all(is.na(EDIT_updates_filtered$ffd_h)) &
    all(is.na(EDIT_updates_filtered$ffd_l))) {print("No data populated in NASIS for this field.")
  
} else{
  
  ffd_r_stats <- rep(ffd.df$value, plyr::round_any(ffd.df$acres/comp_acreage_unit, 
                              accuracy = 1, f = round)) |> sort(na.last = NA)
  
  ffd_r_stats |>  quantile(c(0.2, 0.8), na.rm = TRUE, type = 1)

}

```

**Frost Free Days representative acreage weighted summary statistics**
```{r}
if (all(is.na(EDIT_updates_filtered$ffd_h)) &
    all(is.na(EDIT_updates_filtered$ffd_l))) {print("No data populated in NASIS for this field.")
  
} else{
  
  summary(ffd_r_stats)
  
}

```

<center><h3>**Water features tab:** </h3></center>

Canned statement for both 'Water features narrative' and 'Wetland description':
Due to the topographic position, this site does not have water features or wetlands. 

<center><h3>**Soil features tab:** </h3></center>

#### **Parent material**

**Parent material description frequency**
```{r}
if (all(is.na(EDIT_updates_filtered$parent_material))) {print("No data populated in NASIS for this field.")
  
} else{

 pm_table <- EDIT_updates_filtered |>  dplyr::select(coiid, parent_material, comp_acres) |>  dplyr::group_by(parent_material) |>  
    dplyr::summarise(acres = sum(comp_acres),  '# components' = dplyr::n()) |>  dplyr::arrange(desc(acres)) |>  as.data.frame() 
 
 knitr::kable(pm_table)
 
}
```

**Parent material wordcloud**
```{r, warning=FALSE}

if (all(is.na(EDIT_updates_filtered$parent_material))) {print("No data populated in NASIS for this field.")
  
} else{
    
  parent_material_df <- EDIT_updates_filtered |>  dplyr::select(coiid, parent_material, comp_acres) |>  dplyr::group_by(parent_material) |>  
    dplyr::summarise(acres = sum(comp_acres),  '# components' = dplyr::n()) |>  dplyr::arrange(desc(acres)) |>  as.data.frame()
  
  parent_material_df
  
  acreage_unit <- ifelse(min(parent_material_df$acres[parent_material_df$acres != 0], na.rm = TRUE) < 100, 1, 
               ifelse(min(parent_material_df$acres[parent_material_df$acres != 0], na.rm = TRUE) < 1000, 10, 
                      ifelse(min(parent_material_df$acres[parent_material_df$acres != 0], na.rm = TRUE) < 10000, 100, 
                             ifelse(min(parent_material_df$acres[parent_material_df$acres != 0], na.rm = TRUE) < 
                                      100000, 1000, 10000))))
  
  
 parent_material_words <-  rep(parent_material_df$parent_material, plyr::round_any(parent_material_df$acres/acreage_unit, accuracy = 1, f = round)) |> strsplit(" ") |> unlist() |>   
              stringr::str_replace(",", "")
 
 wordcloud::wordcloud(parent_material_words)

}

```

Make sure to review the full parent material descriptions below to ensure accuracy of wordcloud. Wordcloud relies on prevalence of words used in landform descriptions which is not necessarily associated with the number of components associated with a landform or the number of acres.

#### **Surface texture**

**Full texture string by frequency**
```{r}
if (all(is.na(EDIT_updates_filtered$surf_texture))) {print("No data populated in NASIS for this field.")
  
} else{
  
  EDIT_updates_filtered |>  dplyr::select(coiid, surf_texture, comp_acres) |>  dplyr::group_by(surf_texture) |>  
    dplyr::summarise(acres = sum(comp_acres),  '# components' = dplyr::n()) |>  dplyr::arrange(desc(acres)) |>  as.data.frame()

}
```


#### **Drainage class**

```{r}
if (all(is.na(EDIT_updates_filtered$drainage_class))) {print("No data populated in NASIS for this field.")
  
} else{
  
    my_levels <-  c(
    "subaqueous",
    "very poorly",
    "poorly",
    "somewhat poorly",
    "moderately well",
    "well",
    "somewhat excessively",
    "excessively"
  )
  
drainage_class_df <- EDIT_updates_filtered |>  dplyr::select(coiid, drainage_class, comp_acres)  |>  dplyr::group_by(drainage_class) |>  dplyr::summarise(count = dplyr::n(), acres = sum(comp_acres), coiids = toString(coiid)) |>  dplyr::ungroup() 


drainage_class_df$drainage_class <- factor(drainage_class_df$drainage_class, levels = my_levels)
  
drain1 <-
  plotly::plot_ly(
    x = drainage_class_df$drainage_class,
    y = drainage_class_df$count,
    type = "bar",
    hoverinfo = "text",
    hovertext = paste("coiids: ", stringr::str_wrap(drainage_class_df$coiids, 40))
  ) |>  plotly::layout(
    title = "Drainage class (# components)",
    xaxis = list(title = "Drainage class"),
    yaxis = list(title = "# of components"),
    margin = list(t = 100)
  )


drain2 <-
  plotly::plot_ly(
    x = drainage_class_df$drainage_class,
    y = drainage_class_df$acres,
    name = "Drainage class (acres)",
    type = "bar",
    hoverinfo = "text",
    hovertext = paste("coiids: ", stringr::str_wrap(drainage_class_df$coiids, 40))
  ) |>  plotly::layout(
    title = "Drainage class (# of acres)",
    xaxis = list(title = "Drainage Class"),
    yaxis = list(title = "acres"),
    margin = list(t = 100)
  )

manipulateWidget::combineWidgets(drain1,
                                 drain2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))


}
```

**Drainage class table**

```{r}
if (all(is.na(EDIT_updates_filtered$drainage_class))) {print("No data populated in NASIS for this field.")
  
} else{
  
  EDIT_updates_filtered |>  dplyr::select(coiid, drainage_class, comp_acres) |>  dplyr::group_by(drainage_class) |>  
    dplyr::summarise(acres = sum(comp_acres),  '# components' = dplyr::n()) |>  dplyr::arrange(desc(acres)) |>  as.data.frame()

}
```
**Drainage class acreage weighted percentiles**

Actual low (5%) and actual high (95%). Representative low (20%) and representative high (80%).
```{r}
if (all(is.na(EDIT_updates_filtered$drainage_class))) {print("No data populated in NASIS for this field.")
  
} else{
  
    expanded_drainage_class <- rep(EDIT_updates_filtered$drainage_class, 
                                   times = plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit,
                                                           accuracy = 1, f = round))
    
    expanded_drainage_class <- expanded_drainage_class[order(match(expanded_drainage_class, my_levels))]
    
    data.frame("5%" = expanded_drainage_class[ceiling(0.05 * length(expanded_drainage_class))],
               "20%" = expanded_drainage_class[ceiling(0.20 * length(expanded_drainage_class))],
               "80%" = expanded_drainage_class[ceiling(0.80 * length(expanded_drainage_class))],
             "95%" = expanded_drainage_class[ceiling(0.95 * length(expanded_drainage_class))],
             check.names = FALSE)
  
}
```

#### **Permeability class**
```{r}
if (all(is.na(EDIT_updates_filtered$ksat_l_0_40_in))) {print("No data populated in NASIS for this field.")
  
} else{

  my_levels <-  c(
    "impermeable",
    "very slow",
    "slow",
    "moderately slow",
    "moderately rapid",
    "rapid",
    "very rapid"
  )
  
  EDIT_updates_filtered$ksat_l_0_40_in_mod <-
    plyr::mapvalues(
      EDIT_updates_filtered$ksat_l_0_40_in,
      from = c(
        "very low",
        "low",
        "moderately low",
        "moderately high",
        "high",
        "very high"
      ),
      to = c(
        "very slow",
        "slow",
        "moderately slow",
        "moderately rapid",
        "rapid",
        "very rapid"
      )
    )  
  
drain1 <-
  plotly::plot_ly(
    x = drainage_class_df$drainage_class,
    y = drainage_class_df$count,
    type = "bar",
    hoverinfo = "text",
    hovertext = paste("coiids: ", stringr::str_wrap(drainage_class_df$coiids, 40))
  ) |>  plotly::layout(
    title = "Drainage class (# components)",
    xaxis = list(title = "Drainage class"),
    yaxis = list(title = "# of components"),
    margin = list(t = 100)
  )
  
perm_class_df <- EDIT_updates_filtered |>  dplyr::select(coiid, ksat_l_0_40_in_mod, comp_acres)  |>  dplyr::group_by(ksat_l_0_40_in_mod) |>  dplyr::summarise(count = dplyr::n(), acres = sum(comp_acres), coiids = toString(coiid)) |>  dplyr::ungroup() 

perm_class_df$ksat_l_0_40_in_mod <- factor(perm_class_df$ksat_l_0_40_in_mod, levels = my_levels)
  
perm1 <-
  plotly::plot_ly(
    x = perm_class_df$ksat_l_0_40_in_mod,
    y = perm_class_df$count,
    type = "bar",
    hoverinfo = "text",
    hovertext = paste("coiids: ", stringr::str_wrap(perm_class_df$coiids, 40))
  ) |>  plotly::layout(
    title = "Permeability class (# components)",
    xaxis = list(title = "Permeability class"),
    yaxis = list(title = "# of components"),
    margin = list(t = 100)
  )


perm2 <-
  plotly::plot_ly(
    x = perm_class_df$ksat_l_0_40_in_mod,
    y = perm_class_df$acres,
    name = "Permeability class (acres)",
    type = "bar",
    hoverinfo = "text",
    hovertext = paste("coiids: ", stringr::str_wrap(perm_class_df$coiids, 40))
  ) |>  plotly::layout(
    title = "Permeability class (# of acres)",
    xaxis = list(title = "Permeability class"),
    yaxis = list(title = "acres"),
    margin = list(t = 100)
  )

manipulateWidget::combineWidgets(perm1,
                                 perm2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))


}
```

**Permeability table**

```{r}
if (all(is.na(EDIT_updates_filtered$ksat_l_0_40_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  EDIT_updates_filtered |>  dplyr::select(coiid, ksat_l_0_40_in_mod, comp_acres) |>  dplyr::group_by(ksat_l_0_40_in_mod) |>  
    dplyr::summarise(acres = sum(comp_acres),  '# components' = dplyr::n()) |>  dplyr::arrange(desc(acres)) |>  as.data.frame()

}
```

**Permeability acreage weighted percentiles**

Actual low (5%) and actual high (95%). Representative low (20%) and representative high (80%).
```{r}
if (all(is.na(EDIT_updates_filtered$ksat_l_0_40_in_mod))) {print("No data populated in NASIS for this field.")
  
} else{
  
  
    expanded_perm_class <- rep(EDIT_updates_filtered$ksat_l_0_40_in_mod, EDIT_updates_filtered$comp_acres)
    expanded_perm_class <- expanded_perm_class[order(match(expanded_perm_class, my_levels))]
    
    data.frame("5%" = expanded_perm_class[ceiling(0.05 * length(expanded_perm_class))],
      "20%" = expanded_perm_class[ceiling(0.20 * length(expanded_perm_class))],
             "80%" = expanded_perm_class[ceiling(0.80 * length(expanded_perm_class))],
      "95%" = expanded_perm_class[ceiling(0.95 * length(expanded_perm_class))],
             check.names = FALSE)
  
  
}
```

#### **Depth to restriction**

Depth to restriction prep code
```{r, message=FALSE}

if (all(is.na(EDIT_updates_filtered$restrict_depth_h_in)) & 
    all(is.na(EDIT_updates_filtered$restrict_depth_l_in))) {print("No data populated in NASIS for this field. Enter NA for high (actual).")
  
} else{

# Define bin width and round by measures

bin_width <- 5
round_by <- 5

# Default dataframe

restriction.df <-
  EDIT_updates_filtered |>  dplyr::select(coiid, restrict_depth_h_in, restrict_depth_l_in, comp_acres) |> 
  tidyr::pivot_longer(
    names_to = "restriction",
    values_to = "value",
    cols = c("restrict_depth_h_in", "restrict_depth_l_in")) |> 
  dplyr::rename(acres = comp_acres)

# Sequence for axes

my_list <- list()
my_seq <- seq(0, 90, 5)

}

```




```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$restrict_depth_h_in))) {print("No data populated in NASIS for this field. Enter NA for high (actual).")
  
} else{

# Create component histogram

restriction_h1 <- ggplot2::ggplot(restriction.df |>  dplyr::filter(restriction == "restrict_depth_h_in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = 2.5,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Restriction depth high") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Restriction depth (inches)") +
  ggplot2::scale_x_continuous(limits = c(0, 90),
  breaks = seq(0, 90, 5))

# Convert histogram to plotly

restriction_h1 <- plotly::ggplotly(restriction_h1, tooltip = "text")

# Acreage weighted histogram

restriction_h2 <- ggplot2::ggplot(restriction.df |>  dplyr::filter(restriction == "restrict_depth_h_in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = 2.5,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Restriction depth high") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Restriction depth (inches)") +
  ggplot2::scale_x_continuous(limits = c(0, 90),
  breaks = seq(0, 90, 5))

# Convert to plotly

restriction_h2 <- plotly::ggplotly(restriction_h2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(restriction_h1,
                                 restriction_h2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```


**Restriction depth high table**

NAs in restriction depth likely mean that no restriction was observed. NA's are not represented in the figures above. Please observe the table below to understand the relative acreage classified as NA.
```{r}
if (all(is.na(EDIT_updates_filtered$restrict_depth_h_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  data.frame('# components NA' = sum(is.na(EDIT_updates_filtered$restrict_depth_h_in)),
             '% components NA' = 100*sum(is.na(EDIT_updates_filtered$restrict_depth_h_in))/
               length(EDIT_updates_filtered$restrict_depth_h_in),
             check.names = FALSE)
  
  }
```

**Restriction high acreage weighted 95th percentile** -  use as 'high (actual)'. This value may be NA.  

The percentile calculation for restriction is performed differently because NAs in the restriction likely mean no restriction was observed. For that reason, we will consider NAs to be an ordinal value that is deeper than all other quantitative values.
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$restrict_depth_h_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
    restriction_na_h_rem_expanded <- c(rep(EDIT_updates_filtered$restrict_depth_h_in,
                                             EDIT_updates_filtered$comp_acres/comp_acreage_unit)) |> sort(na.last = TRUE)

    data.frame("95%" = restriction_na_h_rem_expanded[ceiling(0.95 * length(restriction_na_h_rem_expanded))], 
             check.names = FALSE)
  
}

```

**Restriction high acreage weighted summary statistics** - Summary statistics are calculated using numeric values (NA values omitted). The combined acreage of components with an NA value is listed.
```{r}

if (all(is.na(EDIT_updates_filtered$restrict_depth_h_in))) {print("No data populated in NASIS for this field. For restriction, this likely means no restriction was observed.")
  
} else{

  summary(restriction_na_h_rem_expanded)
  
}
```

```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$restrict_depth_l_in))) {print("No data populated in NASIS for this field. Enter NA for low (actual).")
  
} else{

# Create component histogram

restriction_l1 <- ggplot2::ggplot(restriction.df |>  dplyr::filter(restriction == "restrict_depth_l_in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = 2.5,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Restriction depth low") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Restriction depth (inches)") +
  ggplot2::scale_x_continuous(limits = c(0, 90),
  breaks = seq(0, 90, 5))

# Convert histogram to plotly

restriction_l1 <- plotly::ggplotly(restriction_l1, tooltip = "text")

# Acreage weighted histogram

restriction_l2 <- ggplot2::ggplot(restriction.df |>  dplyr::filter(restriction == "restrict_depth_l_in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = 2.5,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Restriction depth low") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Restriction depth (inches)") +
  ggplot2::scale_x_continuous(limits = c(0, 90),
  breaks = seq(0, 90, 5))

# Convert to plotly

restriction_l2 <- plotly::ggplotly(restriction_l2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(restriction_l1,
                                 restriction_l2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Restriction depth low table**

NAs in restriction likely mean that no restriction was observed. NA's are not represented in the figures above. Please observe the table below to understand the acreage and number of component associated with a restriction of NA. 
```{r}
if (all(is.na(EDIT_updates_filtered$restrict_depth_l_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  data.frame('# components NA' = sum(is.na(EDIT_updates_filtered$restrict_depth_l_in)),
             '% components NA' = 100*sum(is.na(EDIT_updates_filtered$restrict_depth_l_in))/
               length(EDIT_updates_filtered$restrict_depth_l_in),
             check.names = FALSE)
  
}
```

**Restriction low: acreage weighted 5th percentile** -  use as 'low (actual)'. This value may be NA. 

The percentile calculation for restriction is performed differently because NAs in the restriction likely mean no restriction was observed. For that reason, we will consider NAs to be an ordinal value that is deeper than all other quantitative values.
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$restrict_depth_l_in))) {print("No data populated in NASIS for this field.")
  
} else{

    restriction_na_l_rem_expanded <- rep(EDIT_updates_filtered$restrict_depth_l_in, EDIT_updates_filtered$comp_acres/comp_acreage_unit)           |> sort(na.last = TRUE)

    data.frame("5%" = restriction_na_l_rem_expanded[ceiling(0.05 * length(restriction_na_l_rem_expanded))], 
             check.names = FALSE)
  
}

```

**Restriction low acreage weighted summary statistics** - Summary statistics are calculated using numeric values (NA values omitted). The combined acreage of components with an NA value is listed.
```{r}

if (all(is.na(EDIT_updates_filtered$restrict_depth_l_in))) {print("No data populated in NASIS for this field. For restriction, this likely means no restriction was observed.")
  
} else{
  
summary(restriction_na_l_rem_expanded)

}
```

```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$restrict_depth_h_in)) &
    all(is.na(EDIT_updates_filtered$restrict_depth_l_in))) {print("No data populated in NASIS for this field. Enter NA for low & high (representative).")
  
} else{

# Create component histogram

restriction_r1 <- ggplot2::ggplot(restriction.df |>  
                                    dplyr::filter(restriction %in% 
                                                    c("restrict_depth_h_in", "restrict_depth_l_in")), 
                                  ggplot2::aes(x = value)) + 
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = 2.5,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Restriction depth representative") + 
  ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Restriction depth (inches)") +
  ggplot2::scale_x_continuous(limits = c(0, 90),
  breaks = seq(0, 90, 5))

# Convert histogram to plotly

restriction_r1 <- plotly::ggplotly(restriction_r1, tooltip = "text")

# Acreage weighted histogram

restriction_r2 <- ggplot2::ggplot(restriction.df |>  
                                    dplyr::filter(restriction %in% 
                                                    c("restrict_depth_h_in", "restrict_depth_l_in")), 
                                  ggplot2::aes(x = value)) + 
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = 2.5,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Restriction depth representative") + 
  ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Restriction depth (inches)") +
  ggplot2::scale_x_continuous(limits = c(0, 90),
  breaks = seq(0, 90, 5))

# Convert to plotly

restriction_r2 <- plotly::ggplotly(restriction_r2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(restriction_r1,
                                 restriction_r2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Restriction depth representative table**

NAs in restriction likely mean that no restriction was observed. NA's are not represented in the figures above. Please observe the table below to understand the acreage and number of component associated with a restriction of NA. 
```{r}
if (all(is.na(EDIT_updates_filtered$restrict_depth_h_in)) &
    all(is.na(EDIT_updates_filtered$restrict_depth_l_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  data.frame('# components NA' = sum(is.na(EDIT_updates_filtered$restrict_depth_h_in)) +
               sum(is.na(EDIT_updates_filtered$restrict_depth_l_in)),
             '% components NA' = 100*(sum(is.na(EDIT_updates_filtered$restrict_depth_h_in)) +
                                        sum(is.na(EDIT_updates_filtered$restrict_depth_l_in)))/
               (length(EDIT_updates_filtered$restrict_depth_h_in) * 2), check.names = FALSE)
  
}
```


**Restriction representative - combined component high/low acreage weighted 20th and 80th percentile** -  use as 'low (representative)' and 'high (representative)'. These values may be NA.  

The percentile calculation for restriction is performed differently because NAs in the restriction likely mean no restriction was observed. For that reason, we will consider NAs to be an ordinal value that is deeper than all other quantitative values.
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$restrict_depth_h_in)) &
    all(is.na(EDIT_updates_filtered$restrict_depth_l_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  restriction_r_sum_stats <- rep(restriction.df$value, plyr::round_any(restriction.df$acres/comp_acreage_unit, accuracy = 1, f = round)) |> sort(na.last = TRUE)

  data.frame("20%" = restriction_r_sum_stats[ceiling(0.2 * length(restriction_r_sum_stats))],
             "80%" = restriction_r_sum_stats[ceiling(0.8 * length(restriction_r_sum_stats))],
             check.names = FALSE)
  
}

```

**Restriction representative acreage weighted summary statistics** - Summary statistics are calculated using numeric values (NA values omitted). The combined acreage of components with an NA value is listed.
```{r}

if (all(is.na(EDIT_updates_filtered$restrict_depth_h_in)) &
    all(is.na(EDIT_updates_filtered$restrict_depth_l_in))) {print("No data populated in NASIS for this field. For restriction, this likely means no restriction was observed.")
  
} else{
  
summary(restriction_r_sum_stats)

}
```

#### **Soil depth**

Soil depth (inches) is the same as depth to restrictive layer. 

#### **Surface frag (< 3 inches)**

Surface frag (< 3 inches) prep code
```{r, message=FALSE}

# NAs in surface frag generally means zero surface frags

EDIT_updates_filtered$frags_hi_2mm_3in_on_surf <- ifelse(is.na(EDIT_updates_filtered$frags_hi_2mm_3in_on_surf), 0, EDIT_updates_filtered$frags_hi_2mm_3in_on_surf)

EDIT_updates_filtered$frags_lo_2mm_3in_on_surf <- ifelse(is.na(EDIT_updates_filtered$frags_lo_2mm_3in_on_surf), 0, EDIT_updates_filtered$frags_lo_2mm_3in_on_surf)

# Is variable NA?

if (all(is.na(EDIT_updates_filtered$frags_hi_2mm_3in_on_surf))) {print("No data populated in NASIS for this field.")
  
} else{

# Define bin width and round by measures

bin_width <- 10
round_by <- 10

# Default dataframe

surf_frag.df <-
  EDIT_updates_filtered |>  
  dplyr::select(coiid, frags_hi_2mm_3in_on_surf, frags_lo_2mm_3in_on_surf, comp_acres) |> 
  tidyr::pivot_longer(
    names_to = "surf_frag",
    values_to = "value",
    cols = c("frags_hi_2mm_3in_on_surf", "frags_lo_2mm_3in_on_surf")) |> 
  dplyr::rename(acres = comp_acres)

# Sequence for axes

my_seq <- seq(plyr::round_any(min(EDIT_updates_filtered$frags_lo_2mm_3in_on_surf, na.rm = TRUE), round_by, f = floor),
  plyr::round_any(max(EDIT_updates_filtered$frags_hi_2mm_3in_on_surf, na.rm = TRUE), round_by, f = ceiling), bin_width)

my_seq <- if(min(my_seq) == min(EDIT_updates_filtered$frags_lo_2mm_3in_on_surf, na.rm = TRUE) &
                   min(EDIT_updates_filtered$frags_lo_2mm_3in_on_surf, na.rm = TRUE) - bin_width >= 0){
  seq(plyr::round_any(min(EDIT_updates_filtered$frags_lo_2mm_3in_on_surf, na.rm = TRUE), round_by, f = floor) - bin_width,
  plyr::round_any(max(EDIT_updates_filtered$frags_hi_2mm_3in_on_surf, na.rm = TRUE), round_by, f = ceiling), bin_width)
} else{
         my_seq            
                  }

}

```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$frags_hi_2mm_3in_on_surf))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

surf_frag1 <- ggplot2::ggplot(surf_frag.df |>  dplyr::filter(surf_frag == "frags_hi_2mm_3in_on_surf"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Surface frag high (< 3 inches)") + 
  ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Surface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

surf_frag1 <- plotly::ggplotly(surf_frag1, tooltip = "text")

# Acreage weighted histogram

surf_frag2 <- ggplot2::ggplot(surf_frag.df |>  dplyr::filter(surf_frag == "frags_hi_2mm_3in_on_surf"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Surface frag high (< 3 inches)") + 
  ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Surface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

surf_frag2 <- plotly::ggplotly(surf_frag2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(surf_frag1,
                                 surf_frag2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Surface frag high (< 3 inches) acreage weighted 95th percentile** - use as 'high (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$frags_hi_2mm_3in_on_surf))) {print("No data populated in NASIS for this field.")
  
} else{
  
  surf_frag_stats <- rep(EDIT_updates_filtered$frags_hi_2mm_3in_on_surf, 
                        plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                        accuracy = 1, f = round)) |> sort(na.last = NA)
  
  surf_frag_stats |> quantile(probs = c(0.95), na.rm = TRUE, type = 1)


}

```


**Surface frag high (< 3 inches) acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$frags_hi_2mm_3in_on_surf))) {print("No data populated in NASIS for this field.")

} else{

  summary(surf_frag_stats)

}
```

```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$frags_lo_2mm_3in_on_surf))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

surf_frag1 <- ggplot2::ggplot(surf_frag.df |>  dplyr::filter(surf_frag == "frags_lo_2mm_3in_on_surf"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Surface frag low (< 3 inches)") + 
  ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Surface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

surf_frag1 <- plotly::ggplotly(surf_frag1, tooltip = "text")

# Acreage weighted histogram

surf_frag2 <- ggplot2::ggplot(surf_frag.df |>  dplyr::filter(surf_frag == "frags_lo_2mm_3in_on_surf"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Surface frag low (< 3 inches)") + 
  ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Surface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

surf_frag2 <- plotly::ggplotly(surf_frag2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(surf_frag1,
                                 surf_frag2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Surface frag low (2 mm. - 3 inches) acreage weighted 5th percentile** - use as 'low (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$frags_lo_2mm_3in_on_surf))) {print("No data populated in NASIS for this field.")
  
} else{
  
    surf_frag_stats <- rep(EDIT_updates_filtered$frags_lo_2mm_3in_on_surf, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, accuracy = 1, 
                        f = round)) |> sort(na.last = NA)
    
    surf_frag_stats |>  quantile(probs = c(0.05), na.rm = TRUE, type = 1)

}

```

**Surface frag low (2 mm. - 3 inches) acreage weighted summary statistics**

```{r}

if (all(is.na(EDIT_updates_filtered$frags_lo_2mm_3in_on_surf))) {print("No data populated in NASIS for this field.")

} else{

  summary(surf_frag_stats)

}
```

```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$frags_hi_2mm_3in_on_surf)) &
    all(is.na(EDIT_updates_filtered$frags_lo_2mm_3in_on_surf))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

surf_frag1 <- ggplot2::ggplot(surf_frag.df |>  dplyr::filter(surf_frag %in% c("frags_hi_2mm_3in_on_surf", "frags_lo_2mm_3in_on_surf") ), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Surface frag rep. (< 3 inches)") + 
  ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Surface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

surf_frag1 <- plotly::ggplotly(surf_frag1, tooltip = "text")

# Acreage weighted histogram

surf_frag2 <- ggplot2::ggplot(surf_frag.df |>  dplyr::filter(surf_frag %in% c("frags_hi_2mm_3in_on_surf", "frags_lo_2mm_3in_on_surf") ), ggplot2::aes(x = value)) + 
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Surface frag rep. (< 3 inches)") + 
  ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Surface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

surf_frag2 <- plotly::ggplotly(surf_frag2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(surf_frag1,
                                 surf_frag2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Surface frag representative (< 3 inches) acreage weighted 20th and 80th percentiles** - use as 'low (representative)' and 'high (representative)' 
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$frags_lo_2mm_3in_on_surf)) &
    all(is.na(EDIT_updates_filtered$frags_hi_2mm_3in_on_surf))) {print("No data populated in NASIS for this field.")
  
} else{
  
  surf_frag_stats <- rep(surf_frag.df$value, plyr::round_any(surf_frag.df$acres/comp_acreage_unit, 
                            accuracy = 1, f = round)) |> sort(na.last = NA)
  
  surf_frag_stats |>  quantile(c(0.2, 0.8), na.rm = TRUE, type = 1)

}

```

**Surface frag representative (< 3 inches) acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$frags_lo_2mm_3in_on_surf)) &
    all(is.na(EDIT_updates_filtered$frags_hi_2mm_3in_on_surf))) {print("No data populated in NASIS for this field.")

} else{

  summary(surf_frag_stats)

}
```

#### **Surface frag (3+ inches)** 

Surface frag (3+ inches) prep code
```{r, message=FALSE}
# NAs in surface frag generally mean zero surface frags

EDIT_updates_filtered$frags_hi_gt_3in_on_surf <- ifelse(is.na(EDIT_updates_filtered$frags_hi_gt_3in_on_surf), 0, EDIT_updates_filtered$frags_hi_gt_3in_on_surf)

EDIT_updates_filtered$frags_lo_gt_3in_on_surf <- ifelse(is.na(EDIT_updates_filtered$frags_lo_gt_3in_on_surf), 0, EDIT_updates_filtered$frags_lo_gt_3in_on_surf)

# Is variable NA?

if (all(is.na(EDIT_updates_filtered$frags_hi_gt_3in_on_surf)) & 
    all(is.na(EDIT_updates_filtered$frags_lo_gt_3in_on_surf))) {print("No data populated in NASIS for this field.")
  
} else{
  
# Define bin width and round by measures

bin_width <- 10
round_by <- 10

# Default dataframe

surf_frag.df <-
  EDIT_updates_filtered |>
  dplyr::select(coiid,
                frags_lo_gt_3in_on_surf,
                frags_hi_gt_3in_on_surf,
                comp_acres) |>
  tidyr::pivot_longer(
    names_to = "surf_frag",
    values_to = "value",
    cols = c("frags_lo_gt_3in_on_surf", "frags_hi_gt_3in_on_surf")
  ) |>
  dplyr::rename(acres = comp_acres)

# Sequence for axes

my_seq <- seq(plyr::round_any(min(EDIT_updates_filtered$frags_lo_gt_3in_on_surf, na.rm = TRUE), round_by, f = floor),
  plyr::round_any(max(EDIT_updates_filtered$frags_hi_gt_3in_on_surf, na.rm = TRUE), round_by, f = ceiling), bin_width)

my_seq <- if(min(my_seq) == min(EDIT_updates_filtered$frags_lo_gt_3in_on_surf, na.rm = TRUE) &
                   min(EDIT_updates_filtered$frags_lo_gt_3in_on_surf, na.rm = TRUE) - bin_width >= 0){
  seq(plyr::round_any(min(EDIT_updates_filtered$frags_lo_gt_3in_on_surf, na.rm = TRUE), round_by, f = floor) - bin_width,
  plyr::round_any(max(EDIT_updates_filtered$frags_hi_gt_3in_on_surf, na.rm = TRUE), round_by, f = ceiling), bin_width)
} else{
         my_seq            
                  }
  
}
```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$frags_hi_gt_3in_on_surf))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

surf_frag1 <- ggplot2::ggplot(surf_frag.df |>  dplyr::filter(surf_frag == "frags_hi_gt_3in_on_surf"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Surface frag high 3 inches +") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Surface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

surf_frag1 <- plotly::ggplotly(surf_frag1, tooltip = "text")

# Acreage weighted histogram

surf_frag2 <- ggplot2::ggplot(surf_frag.df |>  dplyr::filter(surf_frag == "frags_hi_gt_3in_on_surf"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Surface frag high 3 inches +") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Surface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

surf_frag2 <- plotly::ggplotly(surf_frag2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(surf_frag1,
                                 surf_frag2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Surface frag high (3+ inches) acreage weighted 5th percentile** - use as 'high (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$frags_hi_gt_3in_on_surf))) {print("No data populated in NASIS for this field.")
  
} else{
  
  surf_frag_stats <- rep(EDIT_updates_filtered$frags_hi_gt_3in_on_surf, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                                    accuracy = 1, f = round)) |> sort(na.last = NA)
  
  surf_frag_stats |> quantile(probs = c(0.95), na.rm = TRUE, type = 1)

}

```

**Surface frag high (3+ inches) acreage weighted summary statistics**

```{r}

if (all(is.na(EDIT_updates_filtered$frags_hi_gt_3in_on_surf))) {print("No data populated in NASIS for this field.")

} else{

  summary(surf_frag_stats)

}
```

```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$frags_lo_gt_3in_on_surf))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

surf_frag1 <- ggplot2::ggplot(surf_frag.df |>  dplyr::filter(surf_frag == "frags_lo_gt_3in_on_surf"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Surface frag low (3 inches +)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Surface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

surf_frag1 <- plotly::ggplotly(surf_frag1, tooltip = "text")

# Acreage weighted histogram

surf_frag2 <- ggplot2::ggplot(surf_frag.df |>  dplyr::filter(surf_frag == "frags_lo_gt_3in_on_surf"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Surface frag low (3 inches +)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Surface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

surf_frag2 <- plotly::ggplotly(surf_frag2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(surf_frag1,
                                 surf_frag2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Surface frag low (3+ inches) acreage weighted 5th percentile** - use as 'low (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$frags_lo_gt_3in_on_surf))) {print("No data populated in NASIS for this field.")
  
} else{
  
    surf_frag_stats <- rep(EDIT_updates_filtered$frags_lo_gt_3in_on_surf, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                                    accuracy = 1, f = round)) |> sort(na.last = NA)
    
    surf_frag_stats |>  quantile(probs = c(0.05), na.rm = TRUE, type = 1)

}

```

**Surface frag low (3+ inches) acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$frags_lo_gt_3in_on_surf))) {print("No data populated in NASIS for this field.")

} else{

  summary(surf_frag_stats)

}
```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$frags_hi_gt_3in_on_surf)) &
    all(is.na(EDIT_updates_filtered$frags_lo_gt_3in_on_surf))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

surf_frag1 <- ggplot2::ggplot(surf_frag.df |>  dplyr::filter(surf_frag %in% c("frags_hi_gt_3in_on_surf", "frags_lo_gt_3in_on_surf") ), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Surface frag representative (3 inches +)") + 
  ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Surface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

surf_frag1 <- plotly::ggplotly(surf_frag1, tooltip = "text")

# Acreage weighted histogram

surf_frag2 <- ggplot2::ggplot(surf_frag.df |>  dplyr::filter(surf_frag %in% c("frags_hi_gt_3in_on_surf", "frags_lo_gt_3in_on_surf") ), ggplot2::aes(x = value)) + 
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Surface frag representative (3 inches +)") + 
  ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Surface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

surf_frag2 <- plotly::ggplotly(surf_frag2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(surf_frag1,
                                 surf_frag2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Surface frag representative (3+ inches) - combined component high/low acreage weighted 20th and 80th percentiles** - use as 'low (representative)' and 'high (representative)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$frags_hi_gt_3in_on_surf)) &
    all(is.na(EDIT_updates_filtered$frags_lo_gt_3in_on_surf))) {print("No data populated in NASIS for this field.")
  
} else{
  
  surf_frag_stats <- rep(surf_frag.df$value, plyr::round_any(elev.df$acres/comp_acreage_unit, accuracy = 1, f = round)) |> 
    sort(na.last = NA)
  
  surf_frag_stats |>  quantile(c(0.2, 0.8), na.rm = TRUE, type = 1)

}

```

**Surface frag representative (3+ inches) acreage weighted summary statistics**

```{r}

if (all(is.na(EDIT_updates_filtered$frags_hi_gt_3in_on_surf)) &
    all(is.na(EDIT_updates_filtered$frags_lo_gt_3in_on_surf))) {print("No data populated in NASIS for this field.")

} else{

  summary(surf_frag_stats)

}
```

#### **Available water capacity (0 - 40 inches)**

AWC (0 - 40 inches) prep code
```{r, message=FALSE}
if (all(is.na(EDIT_updates_filtered$awc_h_0_40_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
# Define bin width and round by measures

bin_width <- 1
round_by <- 1

# Default dataframe

awc.df <-
  EDIT_updates_filtered |>  dplyr::select(coiid, awc_l_0_40_in, awc_h_0_40_in, comp_acres) |> 
  tidyr::pivot_longer(
    names_to = "awc",
    values_to = "value",
    cols = c("awc_l_0_40_in", "awc_h_0_40_in")) |> 
  dplyr::rename(acres = comp_acres)

# Sequence for axes

my_seq <- seq(plyr::round_any(min(EDIT_updates_filtered$awc_l_0_40_in, na.rm = TRUE), round_by, f = floor),
  plyr::round_any(max(EDIT_updates_filtered$awc_h_0_40_in, na.rm = TRUE), round_by, f = ceiling), bin_width)

my_seq <- if(min(my_seq) == min(EDIT_updates_filtered$awc_l_0_40_in, na.rm = TRUE) &
             min(EDIT_updates_filtered$awc_l_0_40_in, na.rm = TRUE) - bin_width >= 0){
  seq(plyr::round_any(min(EDIT_updates_filtered$awc_l_0_40_in, na.rm = TRUE), round_by, f = floor) - bin_width,
      plyr::round_any(max(EDIT_updates_filtered$awc_h_0_40_in, na.rm = TRUE), round_by, f = ceiling), bin_width)
} else{
  
  my_seq  
  
}
  
}
```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$awc_h_0_40_in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

awc_h1 <- ggplot2::ggplot(awc.df |>  dplyr::filter(awc == "awc_h_0_40_in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("AWC high (0 - 40 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("AWC") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

awc_h1 <- plotly::ggplotly(awc_h1, tooltip = "text")

# Acreage weighted histogram

awc_h2 <- ggplot2::ggplot(awc.df |>  dplyr::filter(awc == "awc_h_0_40_in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weighted = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("AWC high (0 - 40 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("AWC") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

awc_h2 <- plotly::ggplotly(awc_h2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(awc_h1,
                                 awc_h2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**AWC high acreage weighted 95th percentile** -  use as 'high (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$awc_h_0_40_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  awc_stats <- rep(EDIT_updates_filtered$awc_h_0_40_in, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                accuracy = 1, f = round)) |> sort(na.last = NA)
  
  awc_stats |> quantile(probs = c(0.95), na.rm = TRUE, type = 1)

}

```

**AWC high acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$awc_h_0_40_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
summary(awc_stats)

}
```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$awc_l_0_40_in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

awc_l1 <- ggplot2::ggplot(awc.df |>  dplyr::filter(awc == "awc_l_0_40_in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("AWC low (0 - 40 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("AWC") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

awc_l1 <- plotly::ggplotly(awc_l1, tooltip = "text")

# Acreage weighted histogram

awc_l2 <- ggplot2::ggplot(awc.df |>  dplyr::filter(awc == "awc_l_0_40_in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("AWC low (0 - 40 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("AWC") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

awc_l2 <- plotly::ggplotly(awc_l2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(awc_l1,
                                 awc_l2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**AWC low acreage weighted 5th percentile** -  use as 'low (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$awc_l_0_40_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
    awc_stats <- rep(EDIT_updates_filtered$awc_l_0_40_in, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                          accuracy = 1, f = round)) |> sort(na.last = NA)
    
    awc_stats |>  quantile(probs = c(0.05), na.rm = TRUE, type = 1)

}

```

**AWC low acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$awc_l_0_40_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
summary(awc_stats)

}
```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$awc_h_0_40_in)) &
    all(is.na(EDIT_updates_filtered$awc_l_0_40_in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

awc_r1 <- ggplot2::ggplot(awc.df |>  dplyr::filter(awc %in% c("awc_h_0_40_in", "awc_l_0_40_in")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("AWC representative (0 - 40 inches)") + 
  ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("AWC") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

awc_r1 <- plotly::ggplotly(awc_r1, tooltip = "text")

# Acreage weighted histogram

awc_r2 <- ggplot2::ggplot(awc.df |>  dplyr::filter(awc %in% c("awc_h_0_40_in", "awc_l_0_40_in")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("AWC representative (0 - 40 inches)") + 
  ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("AWC") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

awc_r2 <- plotly::ggplotly(awc_r2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(awc_r1,
                                 awc_r2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**AWC representative - combined component high/low acreage weighted 20th and 80th percentile** -  use as 'high (representative)' and 'low (representative)'.
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$awc_h_0_40_in)) &
    all(is.na(EDIT_updates_filtered$awc_l_0_40_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  awc_stats <- rep(awc.df$value, plyr::round_any(awc.df$acres/comp_acreage_unit, 
                            accuracy = 1, f = round)) |> sort(na.last = NA)
  
  awc_stats |>  quantile(c(0.2, 0.8), na.rm = TRUE, type = 1)

}

```

**AWC representative acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$awc_h_0_40_in)) &
    all(is.na(EDIT_updates_filtered$awc_l_0_40_in))) {print("No data populated in NASIS for this field.")
  
} else{
  
summary(awc_stats)

}
```

#### **pH (0-10 inches)**

pH (0-10 inches) prep code
```{r, message=FALSE}

if (all(is.na(EDIT_updates_filtered$pH_h_0_10in)) &
    all(is.na(EDIT_updates_filtered$pH_h_0_10in))) {print("No data populated in NASIS for this field.")
  
} else{

# Define bin width and round by measures

bin_width <- 0.5
round_by <- 1

# Default dataframe

ph.df <-
  EDIT_updates_filtered |>  dplyr::select(coiid, pH_h_0_10in, pH_l_0_10in, comp_acres) |> 
  tidyr::pivot_longer(
    names_to = "ph",
    values_to = "value",
    cols = c("pH_l_0_10in", "pH_h_0_10in")) |> 
  dplyr::rename(acres = comp_acres)

# Sequence for axes

my_seq <- seq(plyr::round_any(min(EDIT_updates_filtered$pH_l_0_10in, na.rm = TRUE), round_by, f = floor),
  plyr::round_any(max(EDIT_updates_filtered$pH_h_0_10in, na.rm = TRUE), round_by, f = ceiling), bin_width)

my_seq <- if(min(my_seq) == min(EDIT_updates_filtered$pH_l_0_10in, na.rm = TRUE) &
             min(EDIT_updates_filtered$pH_l_0_10in, na.rm = TRUE) - bin_width >= 0){
  seq(plyr::round_any(min(EDIT_updates_filtered$pH_l_0_10in, na.rm = TRUE), round_by, f = floor) - bin_width,
      plyr::round_any(max(EDIT_updates_filtered$pH_h_0_10in, na.rm = TRUE), round_by, f = ceiling), bin_width)
} else{
  
  my_seq 
  
}

}

```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$pH_h_0_10in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

ph_h1 <- ggplot2::ggplot(ph.df |>  dplyr::filter(ph == "pH_h_0_10in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("pH high (0 - 10 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("pH") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

ph_h1 <- plotly::ggplotly(ph_h1, tooltip = "text")

# Acreage weighted histogram

ph_h2 <- ggplot2::ggplot(ph.df |>  dplyr::filter(ph == "pH_h_0_10in"), ggplot2::aes(x = value)) + 
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("pH high (0 - 10 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("pH") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

ph_h2 <- plotly::ggplotly(ph_h2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(ph_h1,
                                 ph_h2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**pH high acreage weighted 95th percentile** -  use as 'high (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$pH_h_0_10in))) {print("No data populated in NASIS for this field.")
  
} else{
  

  ph_stats <- rep(EDIT_updates_filtered$pH_h_0_10in, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                accuracy = 1, f = round)) |> sort(na.last = NA)
  
  ph_stats |> quantile(probs = c(0.95), na.rm = TRUE, type = 1)

}

```

**pH high acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$pH_h_0_10in))) {print("No data populated in NASIS for this field.")
  
} else{
  
summary(ph_stats)

}
```

```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$pH_l_0_10in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

ph_l1 <- ggplot2::ggplot(ph.df |>  dplyr::filter(ph == "pH_l_0_10in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("pH low (0 - 10 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("pH") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

ph_l1 <- plotly::ggplotly(ph_l1, tooltip = "text")

# Acreage weighted histogram

ph_l2 <- ggplot2::ggplot(ph.df |>  dplyr::filter(ph == "pH_l_0_10in"), ggplot2::aes(x = value)) +
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("pH low (0 - 10 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("pH") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

ph_l2 <- plotly::ggplotly(ph_l2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(ph_l1,
                                 ph_l2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**pH low acreage weighted 5th percentile** -  use as 'low (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$pH_l_0_10in))) {print("No data populated in NASIS for this field.")
  
} else{
  
    ph_stats <- rep(EDIT_updates_filtered$pH_l_0_10in, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                          accuracy = 1, f = round)) |> sort(na.last = NA)
    
    ph_stats |>  quantile(probs = c(0.05), na.rm = TRUE, type = 1)

}

```

**pH low acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$pH_l_0_10in))) {print("No data populated in NASIS for this field.")
  
} else{
  
summary(ph_stats)

}
```

```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$pH_l_0_10in)) &
    all(is.na(EDIT_updates_filtered$pH_h_0_10in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

ph_r1 <- ggplot2::ggplot(ph.df |>  dplyr::filter(ph %in% c("pH_l_0_10in", "pH_h_0_10in")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("pH representative (0 - 10 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("pH") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

ph_r1 <- plotly::ggplotly(ph_r1, tooltip = "text")

# Acreage weighted histogram

ph_r2 <- ggplot2::ggplot(ph.df |>  dplyr::filter(ph %in% c("pH_l_0_10in", "pH_h_0_10in")), ggplot2::aes(x = value)) +
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("pH representative (0 - 10 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("pH") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

ph_r2 <- plotly::ggplotly(ph_r2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(ph_r1,
                                 ph_r2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```


**pH representative - combined component high/low acreage weighted 20th and 80th percentile** - use as 'low (representative)' & 'high (representative)' 
```{r}
if (all(is.na(EDIT_updates_filtered$pH_l_0_10in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  ph_stats <- rep(ph.df$value, plyr::round_any(ph.df$acres/comp_acreage_unit, 
                            accuracy = 1, f = round)) |> sort(na.last = NA)
  
  ph_stats |>  quantile(c(0.2, 0.8), na.rm = TRUE, type = 1)
  
}
```

**pH representative acreage weighted summary statistics**
```{r}
if (all(is.na(EDIT_updates_filtered$pH_l_0_10in))) {print("No data populated in NASIS for this field.")
  
} else{
  
summary(ph_stats)
  
}
```


#### **pH (10-40 inches)**

pH (10 - 40 inches) prep code
```{r, message=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$pH_h_10_40in)) &
    all(is.na(EDIT_updates_filtered$pH_l_10_40in))) {print("No data populated in NASIS for this field.")

} else{
  
# Define bin width and round by measures

bin_width <- 0.5
round_by <- 1

# Default dataframe

ph.df <-
  EDIT_updates_filtered |>  dplyr::select(coiid, pH_h_10_40in, pH_l_10_40in, comp_acres) |> 
  tidyr::pivot_longer(
    names_to = "ph",
    values_to = "value",
    cols = c("pH_l_10_40in", "pH_h_10_40in")) |> 
  dplyr::rename(acres = comp_acres)
  
# Sequence for axes

my_seq <- seq(plyr::round_any(min(EDIT_updates_filtered$pH_l_10_40in, na.rm = TRUE), round_by, f = floor),
  plyr::round_any(max(EDIT_updates_filtered$pH_h_10_40in, na.rm = TRUE), round_by, f = ceiling), bin_width)

my_seq <- if(min(my_seq) == min(EDIT_updates_filtered$pH_l_10_40in, na.rm = TRUE) &
             min(EDIT_updates_filtered$pH_l_10_40in, na.rm = TRUE) - bin_width >= 0){
  seq(plyr::round_any(min(EDIT_updates_filtered$pH_l_10_40in, na.rm = TRUE), round_by, f = floor) - bin_width,
      plyr::round_any(max(EDIT_updates_filtered$pH_h_10_40in, na.rm = TRUE), round_by, f = ceiling), bin_width)
} else{
  
  my_seq  
  
}

}

```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$pH_h_10_40in))) {print("No data populated in NASIS for this field.")

} else{

# Create component histogram

ph_h1 <- ggplot2::ggplot(ph.df |>  dplyr::filter(ph == "pH_h_10_40in"), ggplot2::aes(x = value)) +
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres),
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") +
  ggplot2::ggtitle("pH high (10 - 40 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("pH") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

ph_h1 <- plotly::ggplotly(ph_h1, tooltip = "text")

# Acreage weighted histogram

ph_h2 <- ggplot2::ggplot(ph.df |>  dplyr::filter(ph == "pH_h_10_40in"), ggplot2::aes(x = value)) + 
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres),
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") +
  #ggplot2::theme_minimal() +
  ggplot2::ggtitle("pH high (10 - 40 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("pH") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

ph_h2 <- plotly::ggplotly(ph_h2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(ph_h1,
                                 ph_h2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**pH high (10-40 inches) acreage weighted 95th percentile** -  use as 'high (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$pH_h_10_40in))) {print("No data populated in NASIS for this field.")

} else{

  ph_stats <- rep(EDIT_updates_filtered$pH_h_10_40in, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                accuracy = 1, f = round)) |> sort(na.last = NA)
  
  ph_stats |> quantile(probs = c(0.95), na.rm = TRUE, type = 1)

}

```

**pH high acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$pH_h_10_40in))) {print("No data populated in NASIS for this field.")

} else{

summary(ph_stats)
  
}
```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$pH_l_10_40in))) {print("No data populated in NASIS for this field.")

} else{

# Create component histogram

ph_l1 <- ggplot2::ggplot(ph.df |>  dplyr::filter(ph == "pH_l_10_40in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)),
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") +
  #ggplot2::theme_minimal() +
  ggplot2::ggtitle("pH low (10 - 40 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("pH") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

ph_l1 <- plotly::ggplotly(ph_l1, tooltip = "text")

# Acreage weighted histogram

ph_l2 <- ggplot2::ggplot(ph.df |>  dplyr::filter(ph == "pH_l_10_40in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)),
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") +
  #ggplot2::theme_minimal() +
  ggplot2::ggtitle("pH low (10 - 40 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("pH") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

ph_l2 <- plotly::ggplotly(ph_l2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(ph_l1,
                                 ph_l2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**pH low (10-40 inches) acreage weighted 5th percentile** -  use as 'low (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$pH_l_10_40in))) {print("No data populated in NASIS for this field.")

} else{

    ph_stats <- rep(EDIT_updates_filtered$pH_l_10_40in, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                          accuracy = 1, f = round)) |> sort(na.last = NA)
    
    ph_stats |>  quantile(probs = c(0.05), na.rm = TRUE, type = 1)

}

```

**pH low (10-40 inches) acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$pH_l_10_40in))) {print("No data populated in NASIS for this field.")

} else{

summary(ph_stats)

}
```

```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$pH_l_10_40in)) &
    all(is.na(EDIT_updates_filtered$pH_h_10_40in))) {print("No data populated in NASIS for this field.")

} else{

# Create component histogram

ph_r1 <- ggplot2::ggplot(ph.df |>  dplyr::filter(ph %in% c("pH_l_10_40in", "pH_h_10_40in") ), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)),
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") +
  ggplot2::ggtitle("pH representative (10 - 40 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("pH") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert histogram to plotly

ph_r1 <- plotly::ggplotly(ph_r1, tooltip = "text")

# Acreage weighted histogram

ph_r2 <- ggplot2::ggplot(ph.df |>  dplyr::filter(ph %in% c("pH_l_10_40in", "pH_h_10_40in") ), ggplot2::aes(x = value)) + 
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres),
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") +
  ggplot2::ggtitle("pH representative (10 - 40 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("pH") +
  ggplot2::scale_x_continuous(limits = c(min(my_seq), max(my_seq)),
  n.breaks = length(my_seq))

# Convert to plotly

ph_r2 <- plotly::ggplotly(ph_r2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(ph_r1,
                                 ph_r2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**pH (10-40 inches) representative - combined component high/low 20th and 80th percentile** - use as 'low (representative)' & 'high (representative)' 
```{r}
if (all(is.na(EDIT_updates_filtered$pH_l_10_40in)) &
    all(is.na(EDIT_updates_filtered$pH_h_10_40in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  ph_stats <- rep(ph.df$value, plyr::round_any(ph.df$acres/comp_acreage_unit, 
                            accuracy = 1, f = round)) |> sort(na.last = NA)
  
  ph_stats |>  quantile(c(0.2, 0.8), na.rm = TRUE, type = 1)

}

```

**pH (10-40 inches) representative acreage weighted summary statistics**
```{r}
if (all(is.na(EDIT_updates_filtered$pH_l_10_40in)) &
    all(is.na(EDIT_updates_filtered$pH_h_10_40in))) {print("No data populated in NASIS for this field.")
  
} else{
  
summary(ph_stats)

}

```

#### **Subsurface frag (2 mm. - 3 inches), 0 - 60 inches.**

Subsurface frag (2 mm. - 3 inches) prep code
```{r, message=FALSE}
# NAs in subsurface frags generally mean zero subsurface frags

EDIT_updates_filtered$subsurf_frags_hi_2mm.3in <- ifelse(is.na(EDIT_updates_filtered$subsurf_frags_hi_2mm.3in), 0, EDIT_updates_filtered$subsurf_frags_hi_2mm.3in)

EDIT_updates_filtered$subsurf_frags_lo_2mm.3in <- ifelse(is.na(EDIT_updates_filtered$subsurf_frags_lo_2mm.3in), 0, EDIT_updates_filtered$subsurf_frags_lo_2mm.3in)

if (all(is.na(EDIT_updates_filtered$subsurf_frags_hi_2mm.3in)) &
    all(is.na(EDIT_updates_filtered$subsurf_frags_lo_2mm.3in))) {print("No data populated in NASIS for this field.")

} else{
  
# Define bin width and round by measures

bin_width <- 10
round_by <- 10

# Prepare dataframe for component histogram

subsurf_frags.df <-
  EDIT_updates_filtered |>  dplyr::select(coiid, 
                                   subsurf_frags_hi_2mm.3in, subsurf_frags_lo_2mm.3in, comp_acres) |> 
  tidyr::pivot_longer(
    names_to = "frag",
    values_to = "value",
    cols = c("subsurf_frags_hi_2mm.3in", "subsurf_frags_lo_2mm.3in")) |> 
  dplyr::rename(acres = comp_acres)

# Sequence for axes
  
my_seq <- seq(plyr::round_any(min(EDIT_updates_filtered$subsurf_frags_lo_2mm.3in, na.rm = TRUE), round_by, f = floor),
  plyr::round_any(max(EDIT_updates_filtered$subsurf_frags_hi_2mm.3in, na.rm = TRUE), round_by, f = ceiling), bin_width)

my_seq <- if(min(my_seq) == min(EDIT_updates_filtered$subsurf_frags_lo_2mm.3in, na.rm = TRUE) &
             min(EDIT_updates_filtered$subsurf_frags_lo_2mm.3in, na.rm = TRUE) - bin_width >= 0){
  seq(plyr::round_any(min(EDIT_updates_filtered$subsurf_frags_lo_2mm.3in, na.rm = TRUE), round_by, f = floor) - bin_width,
      plyr::round_any(max(EDIT_updates_filtered$subsurf_frags_hi_2mm.3in, na.rm = TRUE), round_by, f = ceiling), bin_width)
} else{
  
  my_seq   
  
}
  
}
```


```{r message=FALSE, warning=FALSE}

if (all(is.na(EDIT_updates_filtered$subsurf_frags_hi_2mm.3in))) {print("No data populated in NASIS for this field.")
  
} else{

  # Create component histogram

subsurf_frag_h1 <- ggplot2::ggplot(subsurf_frags.df |>  dplyr::filter(frag == "subsurf_frags_hi_2mm.3in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Subsurface frag high (2 mm. - 3 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

subsurf_frag_h1 <- plotly::ggplotly(subsurf_frag_h1, tooltip = "text")

# Acreage weighted histogram

subsurf_frag_h2 <- ggplot2::ggplot(subsurf_frags.df |>  dplyr::filter(frag == "subsurf_frags_hi_2mm.3in"), ggplot2::aes(x = value)) + 
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Subsurface frag high (2 mm. - 3 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

subsurf_frag_h2 <- plotly::ggplotly(subsurf_frag_h2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(subsurf_frag_h1,
                                 subsurf_frag_h2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Subsurface frag high (2 mm. - 3 inches), 0 - 60 inches, acreage weighted 95th percentile** - use as 'high (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$subsurf_frags_hi_2mm.3in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  subsurf_frag_stats <- rep(EDIT_updates_filtered$subsurf_frags_hi_2mm.3in, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                accuracy = 1, f = round)) |> sort(na.last = NA)
  
  subsurf_frag_stats |> quantile(probs = c(0.95), na.rm = TRUE, type = 1)

}

```

**Subsurface frag high (2 mm. - 3 inches), 0 - 60 inches, acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$subsurf_frags_hi_2mm.3in))) {print("No data populated in NASIS for this field.")

} else{

  summary(subsurf_frag_stats)

}
```

```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$subsurf_frags_lo_2mm.3in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

subsurf_frags_l1 <- ggplot2::ggplot(subsurf_frags.df |>  dplyr::filter(frag == "subsurf_frags_lo_2mm.3in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Subsurface frag low (2 mm. - 3 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

subsurf_frags_l1 <- plotly::ggplotly(subsurf_frags_l1, tooltip = "text")

# Acreage weighted histogram

subsurf_frags_l2 <- ggplot2::ggplot(subsurf_frags.df |>  dplyr::filter(frag == "subsurf_frags_lo_2mm.3in"), ggplot2::aes(x = value)) + 
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Subsurface frag low (2 mm. - 3 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

subsurf_frags_l2 <- plotly::ggplotly(subsurf_frags_l2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(subsurf_frags_l1,
                                 subsurf_frags_l2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Subsurface frag low (2 mm. - 3 inches), 0 - 60 inches, acreage weighted 5th percentile** - use as 'low (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$subsurf_frags_lo_2mm.3in))) {print("No data populated in NASIS for this field.")
  
} else{
  
    subsurf_frag_stats <- rep(EDIT_updates_filtered$subsurf_frags_lo_2mm.3in, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                          accuracy = 1, f = round)) |> sort(na.last = NA)
    
    subsurf_frag_stats |>  quantile(probs = c(0.05), na.rm = TRUE, type = 1)

}

```


**Subsurface frag low (2 mm. - 3 inches), 0 - 60 inches, acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$subsurf_frags_lo_2mm.3in))) {print("No data populated in NASIS for this field.")

} else{

  summary(subsurf_frag_stats)

}
```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$subsurf_frags_lo_2mm.3in)) &
    all(is.na(EDIT_updates_filtered$subsurf_frags_hi_2mm.3in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

subsurf_frag_r1 <- ggplot2::ggplot(subsurf_frags.df |>  dplyr::filter(frag %in% c("subsurf_frags_hi_2mm.3in", "subsurf_frags_lo_2mm.3in")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Subsurface frag rep. (2 mm. - 3 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

subsurf_frag_r1 <- plotly::ggplotly(subsurf_frag_r1, tooltip = "text")

# Acreage weighted histogram

subsurf_frag_r2 <- ggplot2::ggplot(subsurf_frags.df |>  dplyr::filter(frag %in% c("subsurf_frags_hi_2mm.3in", "subsurf_frags_lo_2mm.3in")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Subsurface frag rep. (2 mm. - 3 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

subsurf_frag_r2 <- plotly::ggplotly(subsurf_frag_r2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(subsurf_frag_r1,
                                 subsurf_frag_r2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Subsurface frag representative (2 mm. - 3 inches) - combined component high/low 20th and 80th percentile** - use as 'low (representative)' & 'high (representative)' 
 
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$subsurf_frags_hi_2mm.3in)) &
    all(is.na(EDIT_updates_filtered$subsurf_frags_lo_2mm.3in))) {print("No data populated in NASIS for this field.")

} else{

  subsurf_frag_stats <- rep(subsurf_frags.df$value, plyr::round_any(subsurf_frags.df$acres/comp_acreage_unit, 
                            accuracy = 1, f = round)) |> sort(na.last = NA)
  
  subsurf_frag_stats |>  quantile(c(0.2, 0.8), na.rm = TRUE, type = 1)

}

```

**Subsurface frag representative acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$subsurf_frags_hi_2mm.3in)) &
    all(is.na(EDIT_updates_filtered$subsurf_frags_lo_2mm.3in))) {print("No data populated in NASIS for this field.")

} else{

  summary(subsurf_frag_stats)

}
```

#### **sieve_subsurface frag (2 mm. - 3 inches), 0 - 60 inches.**

sieve_subsurface frag (2 mm. - 3 inches) prep code
```{r, message=FALSE}
# NAs in sieve_subsurface frags generally mean zero sieve_subsurface frags

EDIT_updates_filtered$sieve_subsurf_frags_hi_2mm.3in <- ifelse(is.na(EDIT_updates_filtered$sieve_subsurf_frags_hi_2mm.3in), 0, EDIT_updates_filtered$sieve_subsurf_frags_hi_2mm.3in)

EDIT_updates_filtered$sieve_subsurf_frags_lo_2mm.3in <- ifelse(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_2mm.3in), 0, EDIT_updates_filtered$sieve_subsurf_frags_lo_2mm.3in)

if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_hi_2mm.3in)) &
    all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_2mm.3in))) {print("No data populated in NASIS for this field.")

} else{
  
# Define bin width and round by measures

bin_width <- 10
round_by <- 10

# Prepare dataframe for component histogram

sieve_subsurf_frags.df <-
  EDIT_updates_filtered |>  dplyr::select(coiid, 
                                   sieve_subsurf_frags_hi_2mm.3in, sieve_subsurf_frags_lo_2mm.3in, comp_acres) |> 
  tidyr::pivot_longer(
    names_to = "frag",
    values_to = "value",
    cols = c("sieve_subsurf_frags_hi_2mm.3in", "sieve_subsurf_frags_lo_2mm.3in")) |> 
  dplyr::rename(acres = comp_acres)

# Sequence for axes
  
my_seq <- seq(plyr::round_any(min(EDIT_updates_filtered$sieve_subsurf_frags_lo_2mm.3in, na.rm = TRUE), round_by, f = floor),
  plyr::round_any(max(EDIT_updates_filtered$sieve_subsurf_frags_hi_2mm.3in, na.rm = TRUE), round_by, f = ceiling), bin_width)

my_seq <- if(min(my_seq) == min(EDIT_updates_filtered$sieve_subsurf_frags_lo_2mm.3in, na.rm = TRUE) &
             min(EDIT_updates_filtered$sieve_subsurf_frags_lo_2mm.3in, na.rm = TRUE) - bin_width >= 0){
  seq(plyr::round_any(min(EDIT_updates_filtered$sieve_subsurf_frags_lo_2mm.3in, na.rm = TRUE), round_by, f = floor) - bin_width,
      plyr::round_any(max(EDIT_updates_filtered$sieve_subsurf_frags_hi_2mm.3in, na.rm = TRUE), round_by, f = ceiling), bin_width)
} else{
  
  my_seq   
  
}
  
}
```


```{r message=FALSE, warning=FALSE}

if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_hi_2mm.3in))) {print("No data populated in NASIS for this field.")
  
} else{

  # Create component histogram

sieve_subsurf_frag_h1 <- ggplot2::ggplot(sieve_subsurf_frags.df |>  dplyr::filter(frag == "sieve_subsurf_frags_hi_2mm.3in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("sieve_subsurface frag high (2 mm. - 3 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("sieve_subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

sieve_subsurf_frag_h1 <- plotly::ggplotly(sieve_subsurf_frag_h1, tooltip = "text")

# Acreage weighted histogram

sieve_subsurf_frag_h2 <- ggplot2::ggplot(sieve_subsurf_frags.df |>  dplyr::filter(frag == "sieve_subsurf_frags_hi_2mm.3in"), ggplot2::aes(x = value)) + 
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("sieve_subsurface frag high (2 mm. - 3 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("sieve_subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

sieve_subsurf_frag_h2 <- plotly::ggplotly(sieve_subsurf_frag_h2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(sieve_subsurf_frag_h1,
                                 sieve_subsurf_frag_h2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**sieve_subsurface frag high (2 mm. - 3 inches), 0 - 60 inches, acreage weighted 95th percentile** - use as 'high (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_hi_2mm.3in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  sieve_subsurf_frag_stats <- rep(EDIT_updates_filtered$sieve_subsurf_frags_hi_2mm.3in, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                accuracy = 1, f = round)) |> sort(na.last = NA)
  
  sieve_subsurf_frag_stats |> quantile(probs = c(0.95), na.rm = TRUE, type = 1)

}

```

**sieve_subsurface frag high (2 mm. - 3 inches), 0 - 60 inches, acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_hi_2mm.3in))) {print("No data populated in NASIS for this field.")

} else{

  summary(sieve_subsurf_frag_stats)

}
```

```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_2mm.3in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

sieve_subsurf_frags_l1 <- ggplot2::ggplot(sieve_subsurf_frags.df |>  dplyr::filter(frag == "sieve_subsurf_frags_lo_2mm.3in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("sieve_subsurface frag low (2 mm. - 3 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("sieve_subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

sieve_subsurf_frags_l1 <- plotly::ggplotly(sieve_subsurf_frags_l1, tooltip = "text")

# Acreage weighted histogram

sieve_subsurf_frags_l2 <- ggplot2::ggplot(sieve_subsurf_frags.df |>  dplyr::filter(frag == "sieve_subsurf_frags_lo_2mm.3in"), ggplot2::aes(x = value)) + 
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("sieve_subsurface frag low (2 mm. - 3 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("sieve_subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

sieve_subsurf_frags_l2 <- plotly::ggplotly(sieve_subsurf_frags_l2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(sieve_subsurf_frags_l1,
                                 sieve_subsurf_frags_l2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**sieve_subsurface frag low (2 mm. - 3 inches), 0 - 60 inches, acreage weighted 5th percentile** - use as 'low (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_2mm.3in))) {print("No data populated in NASIS for this field.")
  
} else{
  
    sieve_subsurf_frag_stats <- rep(EDIT_updates_filtered$sieve_subsurf_frags_lo_2mm.3in, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                          accuracy = 1, f = round)) |> sort(na.last = NA)
    
    sieve_subsurf_frag_stats |>  quantile(probs = c(0.05), na.rm = TRUE, type = 1)

}

```


**sieve_subsurface frag low (2 mm. - 3 inches), 0 - 60 inches, acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_2mm.3in))) {print("No data populated in NASIS for this field.")

} else{

  summary(sieve_subsurf_frag_stats)

}
```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_2mm.3in)) &
    all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_hi_2mm.3in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

sieve_subsurf_frag_r1 <- ggplot2::ggplot(sieve_subsurf_frags.df |>  dplyr::filter(frag %in% c("sieve_subsurf_frags_hi_2mm.3in", "sieve_subsurf_frags_lo_2mm.3in")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("sieve_subsurface frag rep. (2 mm. - 3 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("sieve_subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

sieve_subsurf_frag_r1 <- plotly::ggplotly(sieve_subsurf_frag_r1, tooltip = "text")

# Acreage weighted histogram

sieve_subsurf_frag_r2 <- ggplot2::ggplot(sieve_subsurf_frags.df |>  dplyr::filter(frag %in% c("sieve_subsurf_frags_hi_2mm.3in", "sieve_subsurf_frags_lo_2mm.3in")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("sieve_subsurface frag rep. (2 mm. - 3 inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("sieve_subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

sieve_subsurf_frag_r2 <- plotly::ggplotly(sieve_subsurf_frag_r2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(sieve_subsurf_frag_r1,
                                 sieve_subsurf_frag_r2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**sieve_subsurface frag representative (2 mm. - 3 inches) - combined component high/low 20th and 80th percentile** - use as 'low (representative)' & 'high (representative)' 
 
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_hi_2mm.3in)) &
    all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_2mm.3in))) {print("No data populated in NASIS for this field.")

} else{

  sieve_subsurf_frag_stats <- rep(sieve_subsurf_frags.df$value, plyr::round_any(sieve_subsurf_frags.df$acres/comp_acreage_unit, 
                            accuracy = 1, f = round)) |> sort(na.last = NA)
  
  sieve_subsurf_frag_stats |>  quantile(c(0.2, 0.8), na.rm = TRUE, type = 1)

}

```

**sieve_subsurface frag representative acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_hi_2mm.3in)) &
    all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_2mm.3in))) {print("No data populated in NASIS for this field.")

} else{

  summary(sieve_subsurf_frag_stats)

}
```


#### **Subsurface frag (3+ inches)**

Subsurface frag (3+ inches) prep code
```{r, message=FALSE}

EDIT_updates_filtered$subsurf_frags_hi_gt_3in <- ifelse(is.na(EDIT_updates_filtered$subsurf_frags_hi_gt_3in), 0, EDIT_updates_filtered$subsurf_frags_hi_gt_3in)

EDIT_updates_filtered$subsurf_frags_lo_gt_3in <- ifelse(is.na(EDIT_updates_filtered$subsurf_frags_lo_gt_3in), 0, EDIT_updates_filtered$subsurf_frags_lo_gt_3in)

# Is variable NA?

if (all(is.na(EDIT_updates_filtered$subsurf_frags_hi_gt_3in)) &
    all(is.na(EDIT_updates_filtered$subsurf_frags_lo_gt_3in))) {print("No data populated in NASIS for this field.")
  
} else{
  
# Define bin width and round by measures

bin_width <- 10
round_by <- 10

# Default dataframe

subsurf_frags.df <-
  EDIT_updates_filtered |>  dplyr::select(coiid, subsurf_frags_lo_gt_3in,
                                   subsurf_frags_hi_gt_3in, comp_acres) |> 
  tidyr::pivot_longer(
    names_to = "frag",
    values_to = "value",
    cols = c("subsurf_frags_lo_gt_3in", "subsurf_frags_hi_gt_3in")) |> 
  dplyr::rename(acres = comp_acres)

# Sequence for axes
  
my_seq <- seq(plyr::round_any(min(EDIT_updates_filtered$subsurf_frags_lo_gt_3in, na.rm = TRUE), round_by, f = floor),
  plyr::round_any(max(EDIT_updates_filtered$subsurf_frags_hi_gt_3in, na.rm = TRUE), round_by, f = ceiling), bin_width)

my_seq <- if(min(my_seq) == min(EDIT_updates_filtered$subsurf_frags_lo_gt_3in, na.rm = TRUE) &
             min(EDIT_updates_filtered$subsurf_frags_lo_gt_3in, na.rm = TRUE) - bin_width >= 0){
  seq(plyr::round_any(min(EDIT_updates_filtered$subsurf_frags_lo_gt_3in, na.rm = TRUE), round_by, f = floor) - bin_width,
      plyr::round_any(max(EDIT_updates_filtered$subsurf_frags_hi_gt_3in, na.rm = TRUE), round_by, f = ceiling), bin_width)
} else{
  
  my_seq    
  
}
  
}

```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$subsurf_frags_hi_gt_3in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

subsurf_frag_h1 <- ggplot2::ggplot(subsurf_frags.df |>  dplyr::filter(frag == "subsurf_frags_hi_gt_3in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Subsurface frag high (3 inches +)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

subsurf_frag_h1 <- plotly::ggplotly(subsurf_frag_h1, tooltip = "text")

# Acreage weighted histogram

subsurf_frag_h2 <- ggplot2::ggplot(subsurf_frags.df |>  dplyr::filter(frag == "subsurf_frags_hi_gt_3in"), ggplot2::aes(x = value)) + 
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Subsurface frag high (3 inches +)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

subsurf_frag_h2 <- plotly::ggplotly(subsurf_frag_h2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(subsurf_frag_h1,
                                 subsurf_frag_h2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Subsurface frag high (3+ inches), 0 - 60 inches, acreage weighted 95th percentile** - use as 'high (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$subsurf_frags_hi_gt_3in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  subsurf_frag_stats <- rep(EDIT_updates_filtered$subsurf_frags_hi_gt_3in, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                accuracy = 1, f = round)) |> sort(na.last = NA)
  
  subsurf_frag_stats |> quantile(probs = c(0.95), na.rm = TRUE, type = 1)

}

```

**Subsurface frag high (3+ inches), 0 - 60 inches, acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$subsurf_frags_hi_gt_3in)) &
    all(is.na(EDIT_updates_filtered$subsurf_frags_lo_gt_3in))) {print("No data populated in NASIS for this field.")

} else{

  summary(subsurf_frag_stats)

}
```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$subsurf_frags_lo_gt_3in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

subsurf_frag_l1 <- ggplot2::ggplot(subsurf_frags.df |>  dplyr::filter(frag == "subsurf_frags_lo_gt_3in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Subsurface frag low (3+ inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

subsurf_frag_l1 <- plotly::ggplotly(subsurf_frag_l1, tooltip = "text")

# Acreage weighted histogram

subsurf_frag_l2 <- ggplot2::ggplot(subsurf_frags.df |>  dplyr::filter(frag == "subsurf_frags_lo_gt_3in"), ggplot2::aes(x = value)) + 
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Subsurface frag low (3+ inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

subsurf_frag_l2 <- plotly::ggplotly(subsurf_frag_l2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(subsurf_frag_l1,
                                 subsurf_frag_l2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Subsurface frag low (3+ inches), 0 - 60 inches, acreage weighted 5th percentile** - use as 'low (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$subsurf_frags_lo_gt_3in))) {print("No data populated in NASIS for this field.")
  
} else{
  
    subsurf_frag_stats <- rep(EDIT_updates_filtered$subsurf_frags_lo_gt_3in, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                          accuracy = 1, f = round)) |> sort(na.last = NA)
    
    subsurf_frag_stats |>  quantile(probs = c(0.05), na.rm = TRUE, type = 1)

}

```


**Subsurface frag low (3+ inches), 0 - 60 inches, acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$subsurf_frags_lo_gt_3in))) {print("No data populated in NASIS for this field.")

} else{

  summary(subsurf_frag_stats)

}
```

```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$subsurf_frags_hi_gt_3in)) &
    all(is.na(EDIT_updates_filtered$subsurf_frags_lo_gt_3in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

subsurf_frag_r1 <- ggplot2::ggplot(subsurf_frags.df |>  dplyr::filter(frag %in% c("subsurf_frags_hi_gt_3in", "subsurf_frags_lo_gt_3in")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Subsurface frag rep. (3+ inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("Subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

subsurf_frag_r1 <- plotly::ggplotly(subsurf_frag_r1, tooltip = "text")

# Acreage weighted histogram

subsurf_frag_r2 <- ggplot2::ggplot(subsurf_frags.df |>  dplyr::filter(frag %in% c("subsurf_frags_hi_gt_3in", "subsurf_frags_lo_gt_3in")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("Subsurface frag rep. (3+ inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("Subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

subsurf_frag_r2 <- plotly::ggplotly(subsurf_frag_r2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(subsurf_frag_r1,
                                 subsurf_frag_r2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**Subsurface frag representative (3+ inches), 0 - 60 inches, acreage weighted 20th and 80th percentile** -  use as 'low (representative)' and 'high (representative)' 
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$subsurf_frags_hi_gt_3in)) &
    all(is.na(EDIT_updates_filtered$subsurf_frags_lo_gt_3in))) {print("No data populated in NASIS for this field.")

} else{

  subsurf_frag_stats <- rep(subsurf_frags.df$value, plyr::round_any(subsurf_frags.df$acres/comp_acreage_unit, 
                            accuracy = 1, f = round)) |> sort(na.last = NA)
  
  subsurf_frag_stats |>  quantile(c(0.2, 0.8), na.rm = TRUE, type = 1)

}

```

**Subsurface frag representative (3+ inches), 0 - 60 inches, acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$subsurf_frags_hi_gt_3in)) &
    all(is.na(EDIT_updates_filtered$subsurf_frags_lo_gt_3in))) {print("No data populated in NASIS for this field.")

} else{

  summary(subsurf_frag_stats)

}
```

#### **sieve_subsurface frag (3+ inches)**

sieve_subsurface frag (3+ inches) prep code
```{r, message=FALSE}

EDIT_updates_filtered$sieve_subsurf_frags_hi_gt_3in <- ifelse(is.na(EDIT_updates_filtered$sieve_subsurf_frags_hi_gt_3in), 0, EDIT_updates_filtered$sieve_subsurf_frags_hi_gt_3in)

EDIT_updates_filtered$sieve_subsurf_frags_lo_gt_3in <- ifelse(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_gt_3in), 0, EDIT_updates_filtered$sieve_subsurf_frags_lo_gt_3in)

# Is variable NA?

if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_hi_gt_3in)) &
    all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_gt_3in))) {print("No data populated in NASIS for this field.")
  
} else{
  
# Define bin width and round by measures

bin_width <- 10
round_by <- 10

# Default dataframe

sieve_subsurf_frags.df <-
  EDIT_updates_filtered |>  dplyr::select(coiid, sieve_subsurf_frags_lo_gt_3in,
                                   sieve_subsurf_frags_hi_gt_3in, comp_acres) |> 
  tidyr::pivot_longer(
    names_to = "frag",
    values_to = "value",
    cols = c("sieve_subsurf_frags_lo_gt_3in", "sieve_subsurf_frags_hi_gt_3in")) |> 
  dplyr::rename(acres = comp_acres)

# Sequence for axes
  
my_seq <- seq(plyr::round_any(min(EDIT_updates_filtered$sieve_subsurf_frags_lo_gt_3in, na.rm = TRUE), round_by, f = floor),
  plyr::round_any(max(EDIT_updates_filtered$sieve_subsurf_frags_hi_gt_3in, na.rm = TRUE), round_by, f = ceiling), bin_width)

my_seq <- if(min(my_seq) == min(EDIT_updates_filtered$sieve_subsurf_frags_lo_gt_3in, na.rm = TRUE) &
             min(EDIT_updates_filtered$sieve_subsurf_frags_lo_gt_3in, na.rm = TRUE) - bin_width >= 0){
  seq(plyr::round_any(min(EDIT_updates_filtered$sieve_subsurf_frags_lo_gt_3in, na.rm = TRUE), round_by, f = floor) - bin_width,
      plyr::round_any(max(EDIT_updates_filtered$sieve_subsurf_frags_hi_gt_3in, na.rm = TRUE), round_by, f = ceiling), bin_width)
} else{
  
  my_seq    
  
}
  
}

```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_hi_gt_3in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

sieve_subsurf_frag_h1 <- ggplot2::ggplot(sieve_subsurf_frags.df |>  dplyr::filter(frag == "sieve_subsurf_frags_hi_gt_3in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("sieve_subsurface frag high (3 inches +)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("sieve_subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

sieve_subsurf_frag_h1 <- plotly::ggplotly(sieve_subsurf_frag_h1, tooltip = "text")

# Acreage weighted histogram

sieve_subsurf_frag_h2 <- ggplot2::ggplot(sieve_subsurf_frags.df |>  dplyr::filter(frag == "sieve_subsurf_frags_hi_gt_3in"), ggplot2::aes(x = value)) + 
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("sieve_subsurface frag high (3 inches +)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("sieve_subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

sieve_subsurf_frag_h2 <- plotly::ggplotly(sieve_subsurf_frag_h2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(sieve_subsurf_frag_h1,
                                 sieve_subsurf_frag_h2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**sieve_subsurface frag high (3+ inches), 0 - 60 inches, acreage weighted 95th percentile** - use as 'high (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_hi_gt_3in))) {print("No data populated in NASIS for this field.")
  
} else{
  
  sieve_subsurf_frag_stats <- rep(EDIT_updates_filtered$sieve_subsurf_frags_hi_gt_3in, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                accuracy = 1, f = round)) |> sort(na.last = NA)
  
  sieve_subsurf_frag_stats |> quantile(probs = c(0.95), na.rm = TRUE, type = 1)

}

```

**sieve_subsurface frag high (3+ inches), 0 - 60 inches, acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_hi_gt_3in)) &
    all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_gt_3in))) {print("No data populated in NASIS for this field.")

} else{

  summary(sieve_subsurf_frag_stats)

}
```


```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_gt_3in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

sieve_subsurf_frag_l1 <- ggplot2::ggplot(sieve_subsurf_frags.df |>  dplyr::filter(frag == "sieve_subsurf_frags_lo_gt_3in"), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("sieve_subsurface frag low (3+ inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("sieve_subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

sieve_subsurf_frag_l1 <- plotly::ggplotly(sieve_subsurf_frag_l1, tooltip = "text")

# Acreage weighted histogram

sieve_subsurf_frag_l2 <- ggplot2::ggplot(sieve_subsurf_frags.df |>  dplyr::filter(frag == "sieve_subsurf_frags_lo_gt_3in"), ggplot2::aes(x = value)) + 
  ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("sieve_subsurface frag low (3+ inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("sieve_subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

sieve_subsurf_frag_l2 <- plotly::ggplotly(sieve_subsurf_frag_l2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(sieve_subsurf_frag_l1,
                                 sieve_subsurf_frag_l2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**sieve_subsurface frag low (3+ inches), 0 - 60 inches, acreage weighted 5th percentile** - use as 'low (actual)'
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_gt_3in))) {print("No data populated in NASIS for this field.")
  
} else{
  
    sieve_subsurf_frag_stats <- rep(EDIT_updates_filtered$sieve_subsurf_frags_lo_gt_3in, plyr::round_any(EDIT_updates_filtered$comp_acres/comp_acreage_unit, 
                                          accuracy = 1, f = round)) |> sort(na.last = NA)
    
    sieve_subsurf_frag_stats |>  quantile(probs = c(0.05), na.rm = TRUE, type = 1)

}

```


**sieve_subsurface frag low (3+ inches), 0 - 60 inches, acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_gt_3in))) {print("No data populated in NASIS for this field.")

} else{

  summary(sieve_subsurf_frag_stats)

}
```

```{r message=FALSE, warning=FALSE}
# Is variable NA?

if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_hi_gt_3in)) &
    all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_gt_3in))) {print("No data populated in NASIS for this field.")
  
} else{

# Create component histogram

sieve_subsurf_frag_r1 <- ggplot2::ggplot(sieve_subsurf_frags.df |>  dplyr::filter(frag %in% c("sieve_subsurf_frags_hi_gt_3in", "sieve_subsurf_frags_lo_gt_3in")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid)), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("sieve_subsurface frag rep. (3+ inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of components") + ggplot2::xlab("sieve_subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert histogram to plotly

sieve_subsurf_frag_r1 <- plotly::ggplotly(sieve_subsurf_frag_r1, tooltip = "text")

# Acreage weighted histogram

sieve_subsurf_frag_r2 <- ggplot2::ggplot(sieve_subsurf_frags.df |>  dplyr::filter(frag %in% c("sieve_subsurf_frags_hi_gt_3in", "sieve_subsurf_frags_lo_gt_3in")), ggplot2::aes(x = value)) + ggplot2::geom_histogram(ggplot2::aes(text = paste("coiid(s):", coiid), weight = acres), 
  binwidth = bin_width,
  center = min(my_seq) + bin_width/2,
  color = "black",
  fill = "grey") + 
  ggplot2::ggtitle("sieve_subsurface frag rep. (3+ inches)") + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
  ggplot2::ylab("# of acres") + ggplot2::xlab("sieve_subsurface frag (%)") +
  ggplot2::scale_x_continuous(limits = c(0, 100),
  breaks = seq(0,100, 10))

# Convert to plotly

sieve_subsurf_frag_r2 <- plotly::ggplotly(sieve_subsurf_frag_r2, tooltip = "text")

# Join both figures

manipulateWidget::combineWidgets(sieve_subsurf_frag_r1,
                                 sieve_subsurf_frag_r2,
                                 nrow = 1,
                                 ncol = 2,
                                 colsize = c(1, 1))

}

```

**sieve_subsurface frag representative (3+ inches), 0 - 60 inches, acreage weighted 20th and 80th percentile** -  use as 'low (representative)' and 'high (representative)' 
```{r, fig.show="hold", out.width="50%"}
if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_hi_gt_3in)) &
    all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_gt_3in))) {print("No data populated in NASIS for this field.")

} else{

  sieve_subsurf_frag_stats <- rep(sieve_subsurf_frags.df$value, plyr::round_any(sieve_subsurf_frags.df$acres/comp_acreage_unit, 
                            accuracy = 1, f = round)) |> sort(na.last = NA)
  
  sieve_subsurf_frag_stats |>  quantile(c(0.2, 0.8), na.rm = TRUE, type = 1)

}

```

**sieve_subsurface frag representative (3+ inches), 0 - 60 inches, acreage weighted summary statistics**
```{r}

if (all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_hi_gt_3in)) &
    all(is.na(EDIT_updates_filtered$sieve_subsurf_frags_lo_gt_3in))) {print("No data populated in NASIS for this field.")

} else{

  summary(sieve_subsurf_frag_stats)

}
```

#### **Component name**
```{r}

if (all(is.na(EDIT_updates_filtered$compname))) {print("No data populated in NASIS for this field.")
  
} else{

as.data.frame(table(EDIT_updates_filtered$compname)) |>  
  dplyr::rename(`Component name` = Var1) |>  dplyr::arrange(desc(Freq))

}

```


